/**
 * Abiquo community edition
 * cloud management application for hybrid clouds
 * Copyright (C) 2008-2010 - Abiquo Holdings S.L.
 *
 * This application is free software; you can redistribute it and/or
 * modify it under the terms of the GNU LESSER GENERAL PUBLIC
 * LICENSE as published by the Free Software Foundation under
 * version 3 of the License
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * LESSER GENERAL PUBLIC LICENSE v.3 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.abiquo.aimstub;

import java.util.ArrayList;
import java.util.BitSet;
import java.util.Collections;
import java.util.EnumMap;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.thrift.TApplicationException;
import org.apache.thrift.TBase;
import org.apache.thrift.TBaseHelper;
import org.apache.thrift.TException;
import org.apache.thrift.TFieldIdEnum;
import org.apache.thrift.TFieldRequirementType;
import org.apache.thrift.TProcessor;
import org.apache.thrift.meta_data.FieldMetaData;
import org.apache.thrift.meta_data.FieldValueMetaData;
import org.apache.thrift.meta_data.ListMetaData;
import org.apache.thrift.meta_data.StructMetaData;
import org.apache.thrift.protocol.TField;
import org.apache.thrift.protocol.TList;
import org.apache.thrift.protocol.TMessage;
import org.apache.thrift.protocol.TMessageType;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.protocol.TProtocolUtil;
import org.apache.thrift.protocol.TStruct;
import org.apache.thrift.protocol.TType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Aim
{

    public interface Iface
    {

        public void checkRimpConfiguration() throws RimpException, TException;

        public long getDiskFileSize(String virtualImageDatastorePath) throws RimpException,
            TException;

        public List<Datastore> getDatastores() throws RimpException, TException;

        public List<NetInterface> getNetInterfaces() throws RimpException, TException;

        public void copyFromRepositoryToDatastore(String virtualImageRepositoryPath,
            String datastorePath, String virtualMachineUUID) throws RimpException, TException;

        public void deleteVirtualImageFromDatastore(String datastorePath, String virtualMachineUUID)
            throws RimpException, TException;

        public void copyFromDatastoreToRepository(String virtualMachineUUID, String snapshot,
            String destinationRepositoryPath, String sourceDatastorePath) throws RimpException,
            TException;

        public void createVLAN(int vlanTag, String vlanInterface, String bridgeInterface)
            throws VLanException, TException;

        public void deleteVLAN(int vlanTag, String vlanInterface, String bridgeInterface)
            throws VLanException, TException;

        public void checkVLANConfiguration() throws VLanException, TException;

        public String getInitiatorIQN() throws StorageException, TException;

        public void rescanISCSI(List<String> targets) throws StorageException, TException;

    }

    public static class Client implements Iface
    {
        public Client(final TProtocol prot)
        {
            this(prot, prot);
        }

        public Client(final TProtocol iprot, final TProtocol oprot)
        {
            iprot_ = iprot;
            oprot_ = oprot;
        }

        protected TProtocol iprot_;

        protected TProtocol oprot_;

        protected int seqid_;

        public TProtocol getInputProtocol()
        {
            return this.iprot_;
        }

        public TProtocol getOutputProtocol()
        {
            return this.oprot_;
        }

        @Override
        public void checkRimpConfiguration() throws RimpException, TException
        {
            send_checkRimpConfiguration();
            recv_checkRimpConfiguration();
        }

        public void send_checkRimpConfiguration() throws TException
        {
            oprot_.writeMessageBegin(new TMessage("checkRimpConfiguration",
                TMessageType.CALL,
                seqid_));
            checkRimpConfiguration_args args = new checkRimpConfiguration_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_checkRimpConfiguration() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            checkRimpConfiguration_result result = new checkRimpConfiguration_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.re != null)
            {
                throw result.re;
            }
            return;
        }

        @Override
        public long getDiskFileSize(final String virtualImageDatastorePath) throws RimpException,
            TException
        {
            send_getDiskFileSize(virtualImageDatastorePath);
            return recv_getDiskFileSize();
        }

        public void send_getDiskFileSize(final String virtualImageDatastorePath) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.CALL, seqid_));
            getDiskFileSize_args args = new getDiskFileSize_args();
            args.virtualImageDatastorePath = virtualImageDatastorePath;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public long recv_getDiskFileSize() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            getDiskFileSize_result result = new getDiskFileSize_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess())
            {
                return result.success;
            }
            if (result.re != null)
            {
                throw result.re;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT,
                "getDiskFileSize failed: unknown result");
        }

        @Override
        public List<Datastore> getDatastores() throws RimpException, TException
        {
            send_getDatastores();
            return recv_getDatastores();
        }

        public void send_getDatastores() throws TException
        {
            oprot_.writeMessageBegin(new TMessage("getDatastores", TMessageType.CALL, seqid_));
            getDatastores_args args = new getDatastores_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public List<Datastore> recv_getDatastores() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            getDatastores_result result = new getDatastores_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess())
            {
                return result.success;
            }
            if (result.re != null)
            {
                throw result.re;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT,
                "getDatastores failed: unknown result");
        }

        @Override
        public List<NetInterface> getNetInterfaces() throws RimpException, TException
        {
            send_getNetInterfaces();
            return recv_getNetInterfaces();
        }

        public void send_getNetInterfaces() throws TException
        {
            oprot_.writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.CALL, seqid_));
            getNetInterfaces_args args = new getNetInterfaces_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public List<NetInterface> recv_getNetInterfaces() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            getNetInterfaces_result result = new getNetInterfaces_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess())
            {
                return result.success;
            }
            if (result.re != null)
            {
                throw result.re;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT,
                "getNetInterfaces failed: unknown result");
        }

        @Override
        public void copyFromRepositoryToDatastore(final String virtualImageRepositoryPath,
            final String datastorePath, final String virtualMachineUUID) throws RimpException,
            TException
        {
            send_copyFromRepositoryToDatastore(virtualImageRepositoryPath, datastorePath,
                virtualMachineUUID);
            recv_copyFromRepositoryToDatastore();
        }

        public void send_copyFromRepositoryToDatastore(final String virtualImageRepositoryPath,
            final String datastorePath, final String virtualMachineUUID) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore",
                TMessageType.CALL,
                seqid_));
            copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
            args.virtualImageRepositoryPath = virtualImageRepositoryPath;
            args.datastorePath = datastorePath;
            args.virtualMachineUUID = virtualMachineUUID;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_copyFromRepositoryToDatastore() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            copyFromRepositoryToDatastore_result result =
                new copyFromRepositoryToDatastore_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.re != null)
            {
                throw result.re;
            }
            return;
        }

        @Override
        public void deleteVirtualImageFromDatastore(final String datastorePath,
            final String virtualMachineUUID) throws RimpException, TException
        {
            send_deleteVirtualImageFromDatastore(datastorePath, virtualMachineUUID);
            recv_deleteVirtualImageFromDatastore();
        }

        public void send_deleteVirtualImageFromDatastore(final String datastorePath,
            final String virtualMachineUUID) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore",
                TMessageType.CALL,
                seqid_));
            deleteVirtualImageFromDatastore_args args = new deleteVirtualImageFromDatastore_args();
            args.datastorePath = datastorePath;
            args.virtualMachineUUID = virtualMachineUUID;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_deleteVirtualImageFromDatastore() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            deleteVirtualImageFromDatastore_result result =
                new deleteVirtualImageFromDatastore_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.re != null)
            {
                throw result.re;
            }
            return;
        }

        @Override
        public void copyFromDatastoreToRepository(final String virtualMachineUUID,
            final String snapshot, final String destinationRepositoryPath,
            final String sourceDatastorePath) throws RimpException, TException
        {
            send_copyFromDatastoreToRepository(virtualMachineUUID, snapshot,
                destinationRepositoryPath, sourceDatastorePath);
            recv_copyFromDatastoreToRepository();
        }

        public void send_copyFromDatastoreToRepository(final String virtualMachineUUID,
            final String snapshot, final String destinationRepositoryPath,
            final String sourceDatastorePath) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("copyFromDatastoreToRepository",
                TMessageType.CALL,
                seqid_));
            copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
            args.virtualMachineUUID = virtualMachineUUID;
            args.snapshot = snapshot;
            args.destinationRepositoryPath = destinationRepositoryPath;
            args.sourceDatastorePath = sourceDatastorePath;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_copyFromDatastoreToRepository() throws RimpException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            copyFromDatastoreToRepository_result result =
                new copyFromDatastoreToRepository_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.re != null)
            {
                throw result.re;
            }
            return;
        }

        @Override
        public void createVLAN(final int vlanTag, final String vlanInterface,
            final String bridgeInterface) throws VLanException, TException
        {
            send_createVLAN(vlanTag, vlanInterface, bridgeInterface);
            recv_createVLAN();
        }

        public void send_createVLAN(final int vlanTag, final String vlanInterface,
            final String bridgeInterface) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("createVLAN", TMessageType.CALL, seqid_));
            createVLAN_args args = new createVLAN_args();
            args.vlanTag = vlanTag;
            args.vlanInterface = vlanInterface;
            args.bridgeInterface = bridgeInterface;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_createVLAN() throws VLanException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            createVLAN_result result = new createVLAN_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.ve != null)
            {
                throw result.ve;
            }
            return;
        }

        @Override
        public void deleteVLAN(final int vlanTag, final String vlanInterface,
            final String bridgeInterface) throws VLanException, TException
        {
            send_deleteVLAN(vlanTag, vlanInterface, bridgeInterface);
            recv_deleteVLAN();
        }

        public void send_deleteVLAN(final int vlanTag, final String vlanInterface,
            final String bridgeInterface) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.CALL, seqid_));
            deleteVLAN_args args = new deleteVLAN_args();
            args.vlanTag = vlanTag;
            args.vlanInterface = vlanInterface;
            args.bridgeInterface = bridgeInterface;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_deleteVLAN() throws VLanException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            deleteVLAN_result result = new deleteVLAN_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.ve != null)
            {
                throw result.ve;
            }
            return;
        }

        @Override
        public void checkVLANConfiguration() throws VLanException, TException
        {
            send_checkVLANConfiguration();
            recv_checkVLANConfiguration();
        }

        public void send_checkVLANConfiguration() throws TException
        {
            oprot_.writeMessageBegin(new TMessage("checkVLANConfiguration",
                TMessageType.CALL,
                seqid_));
            checkVLANConfiguration_args args = new checkVLANConfiguration_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_checkVLANConfiguration() throws VLanException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            checkVLANConfiguration_result result = new checkVLANConfiguration_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.ve != null)
            {
                throw result.ve;
            }
            return;
        }

        @Override
        public String getInitiatorIQN() throws StorageException, TException
        {
            send_getInitiatorIQN();
            return recv_getInitiatorIQN();
        }

        public void send_getInitiatorIQN() throws TException
        {
            oprot_.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.CALL, seqid_));
            getInitiatorIQN_args args = new getInitiatorIQN_args();
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public String recv_getInitiatorIQN() throws StorageException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            getInitiatorIQN_result result = new getInitiatorIQN_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.isSetSuccess())
            {
                return result.success;
            }
            if (result.se != null)
            {
                throw result.se;
            }
            throw new TApplicationException(TApplicationException.MISSING_RESULT,
                "getInitiatorIQN failed: unknown result");
        }

        @Override
        public void rescanISCSI(final List<String> targets) throws StorageException, TException
        {
            send_rescanISCSI(targets);
            recv_rescanISCSI();
        }

        public void send_rescanISCSI(final List<String> targets) throws TException
        {
            oprot_.writeMessageBegin(new TMessage("rescanISCSI", TMessageType.CALL, seqid_));
            rescanISCSI_args args = new rescanISCSI_args();
            args.targets = targets;
            args.write(oprot_);
            oprot_.writeMessageEnd();
            oprot_.getTransport().flush();
        }

        public void recv_rescanISCSI() throws StorageException, TException
        {
            TMessage msg = iprot_.readMessageBegin();
            if (msg.type == TMessageType.EXCEPTION)
            {
                TApplicationException x = TApplicationException.read(iprot_);
                iprot_.readMessageEnd();
                throw x;
            }
            rescanISCSI_result result = new rescanISCSI_result();
            result.read(iprot_);
            iprot_.readMessageEnd();
            if (result.se != null)
            {
                throw result.se;
            }
            return;
        }

    }

    public static class Processor implements TProcessor
    {
        private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());

        public Processor(final Iface iface)
        {
            iface_ = iface;
            processMap_.put("checkRimpConfiguration", new checkRimpConfiguration());
            processMap_.put("getDiskFileSize", new getDiskFileSize());
            processMap_.put("getDatastores", new getDatastores());
            processMap_.put("getNetInterfaces", new getNetInterfaces());
            processMap_.put("copyFromRepositoryToDatastore", new copyFromRepositoryToDatastore());
            processMap_.put("deleteVirtualImageFromDatastore",
                new deleteVirtualImageFromDatastore());
            processMap_.put("copyFromDatastoreToRepository", new copyFromDatastoreToRepository());
            processMap_.put("createVLAN", new createVLAN());
            processMap_.put("deleteVLAN", new deleteVLAN());
            processMap_.put("checkVLANConfiguration", new checkVLANConfiguration());
            processMap_.put("getInitiatorIQN", new getInitiatorIQN());
            processMap_.put("rescanISCSI", new rescanISCSI());
        }

        protected static interface ProcessFunction
        {
            public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
        }

        private Iface iface_;

        protected final HashMap<String, ProcessFunction> processMap_ =
            new HashMap<String, ProcessFunction>();

        @Override
        public boolean process(final TProtocol iprot, final TProtocol oprot) throws TException
        {
            TMessage msg = iprot.readMessageBegin();
            ProcessFunction fn = processMap_.get(msg.name);
            if (fn == null)
            {
                TProtocolUtil.skip(iprot, TType.STRUCT);
                iprot.readMessageEnd();
                TApplicationException x =
                    new TApplicationException(TApplicationException.UNKNOWN_METHOD,
                        "Invalid method name: '" + msg.name + "'");
                oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
                x.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
                return true;
            }
            fn.process(msg.seqid, iprot, oprot);
            return true;
        }

        private class checkRimpConfiguration implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                checkRimpConfiguration_args args = new checkRimpConfiguration_args();
                args.read(iprot);
                iprot.readMessageEnd();
                checkRimpConfiguration_result result = new checkRimpConfiguration_result();
                try
                {
                    iface_.checkRimpConfiguration();
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing checkRimpConfiguration", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing checkRimpConfiguration");
                    oprot.writeMessageBegin(new TMessage("checkRimpConfiguration",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("checkRimpConfiguration",
                    TMessageType.REPLY,
                    seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class getDiskFileSize implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                getDiskFileSize_args args = new getDiskFileSize_args();
                args.read(iprot);
                iprot.readMessageEnd();
                getDiskFileSize_result result = new getDiskFileSize_result();
                try
                {
                    result.success = iface_.getDiskFileSize(args.virtualImageDatastorePath);
                    result.setSuccessIsSet(true);
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing getDiskFileSize", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing getDiskFileSize");
                    oprot.writeMessageBegin(new TMessage("getDiskFileSize",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("getDiskFileSize", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class getDatastores implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                getDatastores_args args = new getDatastores_args();
                args.read(iprot);
                iprot.readMessageEnd();
                getDatastores_result result = new getDatastores_result();
                try
                {
                    result.success = iface_.getDatastores();
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing getDatastores", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing getDatastores");
                    oprot.writeMessageBegin(new TMessage("getDatastores",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("getDatastores", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class getNetInterfaces implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                getNetInterfaces_args args = new getNetInterfaces_args();
                args.read(iprot);
                iprot.readMessageEnd();
                getNetInterfaces_result result = new getNetInterfaces_result();
                try
                {
                    result.success = iface_.getNetInterfaces();
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing getNetInterfaces", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing getNetInterfaces");
                    oprot.writeMessageBegin(new TMessage("getNetInterfaces",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot
                    .writeMessageBegin(new TMessage("getNetInterfaces", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class copyFromRepositoryToDatastore implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                copyFromRepositoryToDatastore_args args = new copyFromRepositoryToDatastore_args();
                args.read(iprot);
                iprot.readMessageEnd();
                copyFromRepositoryToDatastore_result result =
                    new copyFromRepositoryToDatastore_result();
                try
                {
                    iface_.copyFromRepositoryToDatastore(args.virtualImageRepositoryPath,
                        args.datastorePath, args.virtualMachineUUID);
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing copyFromRepositoryToDatastore", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing copyFromRepositoryToDatastore");
                    oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("copyFromRepositoryToDatastore",
                    TMessageType.REPLY,
                    seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class deleteVirtualImageFromDatastore implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                deleteVirtualImageFromDatastore_args args =
                    new deleteVirtualImageFromDatastore_args();
                args.read(iprot);
                iprot.readMessageEnd();
                deleteVirtualImageFromDatastore_result result =
                    new deleteVirtualImageFromDatastore_result();
                try
                {
                    iface_.deleteVirtualImageFromDatastore(args.datastorePath,
                        args.virtualMachineUUID);
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing deleteVirtualImageFromDatastore", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing deleteVirtualImageFromDatastore");
                    oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("deleteVirtualImageFromDatastore",
                    TMessageType.REPLY,
                    seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class copyFromDatastoreToRepository implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                copyFromDatastoreToRepository_args args = new copyFromDatastoreToRepository_args();
                args.read(iprot);
                iprot.readMessageEnd();
                copyFromDatastoreToRepository_result result =
                    new copyFromDatastoreToRepository_result();
                try
                {
                    iface_.copyFromDatastoreToRepository(args.virtualMachineUUID, args.snapshot,
                        args.destinationRepositoryPath, args.sourceDatastorePath);
                }
                catch (RimpException re)
                {
                    result.re = re;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing copyFromDatastoreToRepository", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing copyFromDatastoreToRepository");
                    oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("copyFromDatastoreToRepository",
                    TMessageType.REPLY,
                    seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class createVLAN implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                createVLAN_args args = new createVLAN_args();
                args.read(iprot);
                iprot.readMessageEnd();
                createVLAN_result result = new createVLAN_result();
                try
                {
                    iface_.createVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
                }
                catch (VLanException ve)
                {
                    result.ve = ve;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing createVLAN", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing createVLAN");
                    oprot.writeMessageBegin(new TMessage("createVLAN",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("createVLAN", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class deleteVLAN implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                deleteVLAN_args args = new deleteVLAN_args();
                args.read(iprot);
                iprot.readMessageEnd();
                deleteVLAN_result result = new deleteVLAN_result();
                try
                {
                    iface_.deleteVLAN(args.vlanTag, args.vlanInterface, args.bridgeInterface);
                }
                catch (VLanException ve)
                {
                    result.ve = ve;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing deleteVLAN", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing deleteVLAN");
                    oprot.writeMessageBegin(new TMessage("deleteVLAN",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("deleteVLAN", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class checkVLANConfiguration implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                checkVLANConfiguration_args args = new checkVLANConfiguration_args();
                args.read(iprot);
                iprot.readMessageEnd();
                checkVLANConfiguration_result result = new checkVLANConfiguration_result();
                try
                {
                    iface_.checkVLANConfiguration();
                }
                catch (VLanException ve)
                {
                    result.ve = ve;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing checkVLANConfiguration", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing checkVLANConfiguration");
                    oprot.writeMessageBegin(new TMessage("checkVLANConfiguration",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("checkVLANConfiguration",
                    TMessageType.REPLY,
                    seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class getInitiatorIQN implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                getInitiatorIQN_args args = new getInitiatorIQN_args();
                args.read(iprot);
                iprot.readMessageEnd();
                getInitiatorIQN_result result = new getInitiatorIQN_result();
                try
                {
                    result.success = iface_.getInitiatorIQN();
                }
                catch (StorageException se)
                {
                    result.se = se;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing getInitiatorIQN", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing getInitiatorIQN");
                    oprot.writeMessageBegin(new TMessage("getInitiatorIQN",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("getInitiatorIQN", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

        private class rescanISCSI implements ProcessFunction
        {
            @Override
            public void process(final int seqid, final TProtocol iprot, final TProtocol oprot)
                throws TException
            {
                rescanISCSI_args args = new rescanISCSI_args();
                args.read(iprot);
                iprot.readMessageEnd();
                rescanISCSI_result result = new rescanISCSI_result();
                try
                {
                    iface_.rescanISCSI(args.targets);
                }
                catch (StorageException se)
                {
                    result.se = se;
                }
                catch (Throwable th)
                {
                    LOGGER.error("Internal error processing rescanISCSI", th);
                    TApplicationException x =
                        new TApplicationException(TApplicationException.INTERNAL_ERROR,
                            "Internal error processing rescanISCSI");
                    oprot.writeMessageBegin(new TMessage("rescanISCSI",
                        TMessageType.EXCEPTION,
                        seqid));
                    x.write(oprot);
                    oprot.writeMessageEnd();
                    oprot.getTransport().flush();
                    return;
                }
                oprot.writeMessageBegin(new TMessage("rescanISCSI", TMessageType.REPLY, seqid));
                result.write(oprot);
                oprot.writeMessageEnd();
                oprot.getTransport().flush();
            }

        }

    }

    public static class checkRimpConfiguration_args implements
        TBase<checkRimpConfiguration_args._Fields>, java.io.Serializable, Cloneable,
        Comparable<checkRimpConfiguration_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_args");

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            ;

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_args.class, metaDataMap);
        }

        public checkRimpConfiguration_args()
        {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public checkRimpConfiguration_args(final checkRimpConfiguration_args other)
        {
        }

        @Override
        public checkRimpConfiguration_args deepCopy()
        {
            return new checkRimpConfiguration_args(this);
        }

        @Override
        @Deprecated
        public checkRimpConfiguration_args clone()
        {
            return new checkRimpConfiguration_args(this);
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof checkRimpConfiguration_args)
            {
                return this.equals((checkRimpConfiguration_args) that);
            }
            return false;
        }

        public boolean equals(final checkRimpConfiguration_args that)
        {
            if (that == null)
            {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final checkRimpConfiguration_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            checkRimpConfiguration_args typedOther = other;

            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("checkRimpConfiguration_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class checkRimpConfiguration_result implements
        TBase<checkRimpConfiguration_result._Fields>, java.io.Serializable, Cloneable,
        Comparable<checkRimpConfiguration_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("checkRimpConfiguration_result");

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(checkRimpConfiguration_result.class, metaDataMap);
        }

        public checkRimpConfiguration_result()
        {
        }

        public checkRimpConfiguration_result(final RimpException re)
        {
            this();
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public checkRimpConfiguration_result(final checkRimpConfiguration_result other)
        {
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public checkRimpConfiguration_result deepCopy()
        {
            return new checkRimpConfiguration_result(this);
        }

        @Override
        @Deprecated
        public checkRimpConfiguration_result clone()
        {
            return new checkRimpConfiguration_result(this);
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public checkRimpConfiguration_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof checkRimpConfiguration_result)
            {
                return this.equals((checkRimpConfiguration_result) that);
            }
            return false;
        }

        public boolean equals(final checkRimpConfiguration_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final checkRimpConfiguration_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            checkRimpConfiguration_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("checkRimpConfiguration_result(");
            boolean first = true;

            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getDiskFileSize_args implements TBase<getDiskFileSize_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<getDiskFileSize_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_args");

        private static final TField VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC =
            new TField("virtualImageDatastorePath", TType.STRING, (short) 1);

        public String virtualImageDatastorePath;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VIRTUAL_IMAGE_DATASTORE_PATH((short) 1, "virtualImageDatastorePath");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VIRTUAL_IMAGE_DATASTORE_PATH,
                        new FieldMetaData("virtualImageDatastorePath",
                            TFieldRequirementType.DEFAULT,
                            new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getDiskFileSize_args.class, metaDataMap);
        }

        public getDiskFileSize_args()
        {
        }

        public getDiskFileSize_args(final String virtualImageDatastorePath)
        {
            this();
            this.virtualImageDatastorePath = virtualImageDatastorePath;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getDiskFileSize_args(final getDiskFileSize_args other)
        {
            if (other.isSetVirtualImageDatastorePath())
            {
                this.virtualImageDatastorePath = other.virtualImageDatastorePath;
            }
        }

        @Override
        public getDiskFileSize_args deepCopy()
        {
            return new getDiskFileSize_args(this);
        }

        @Override
        @Deprecated
        public getDiskFileSize_args clone()
        {
            return new getDiskFileSize_args(this);
        }

        public String getVirtualImageDatastorePath()
        {
            return this.virtualImageDatastorePath;
        }

        public getDiskFileSize_args setVirtualImageDatastorePath(
            final String virtualImageDatastorePath)
        {
            this.virtualImageDatastorePath = virtualImageDatastorePath;
            return this;
        }

        public void unsetVirtualImageDatastorePath()
        {
            this.virtualImageDatastorePath = null;
        }

        /**
         * Returns true if field virtualImageDatastorePath is set (has been asigned a value) and
         * false otherwise
         */
        public boolean isSetVirtualImageDatastorePath()
        {
            return this.virtualImageDatastorePath != null;
        }

        public void setVirtualImageDatastorePathIsSet(final boolean value)
        {
            if (!value)
            {
                this.virtualImageDatastorePath = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_DATASTORE_PATH:
                    if (value == null)
                    {
                        unsetVirtualImageDatastorePath();
                    }
                    else
                    {
                        setVirtualImageDatastorePath((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_DATASTORE_PATH:
                    return getVirtualImageDatastorePath();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_DATASTORE_PATH:
                    return isSetVirtualImageDatastorePath();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getDiskFileSize_args)
            {
                return this.equals((getDiskFileSize_args) that);
            }
            return false;
        }

        public boolean equals(final getDiskFileSize_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_virtualImageDatastorePath =
                true && this.isSetVirtualImageDatastorePath();
            boolean that_present_virtualImageDatastorePath =
                true && that.isSetVirtualImageDatastorePath();
            if (this_present_virtualImageDatastorePath || that_present_virtualImageDatastorePath)
            {
                if (!(this_present_virtualImageDatastorePath && that_present_virtualImageDatastorePath))
                {
                    return false;
                }
                if (!this.virtualImageDatastorePath.equals(that.virtualImageDatastorePath))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getDiskFileSize_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getDiskFileSize_args typedOther = other;

            lastComparison =
                Boolean.valueOf(isSetVirtualImageDatastorePath()).compareTo(
                    isSetVirtualImageDatastorePath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(virtualImageDatastorePath,
                    typedOther.virtualImageDatastorePath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VIRTUAL_IMAGE_DATASTORE_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.virtualImageDatastorePath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.virtualImageDatastorePath != null)
            {
                oprot.writeFieldBegin(VIRTUAL_IMAGE_DATASTORE_PATH_FIELD_DESC);
                oprot.writeString(this.virtualImageDatastorePath);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getDiskFileSize_args(");
            boolean first = true;

            sb.append("virtualImageDatastorePath:");
            if (this.virtualImageDatastorePath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.virtualImageDatastorePath);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getDiskFileSize_result implements TBase<getDiskFileSize_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<getDiskFileSize_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getDiskFileSize_result");

        private static final TField SUCCESS_FIELD_DESC =
            new TField("success", TType.I64, (short) 0);

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public long success;

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            SUCCESS((short) 0, "success"), RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments
        private static final int __SUCCESS_ISSET_ID = 0;

        private BitSet __isset_bit_vector = new BitSet(1);

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.SUCCESS, new FieldMetaData("success",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.I64)));
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getDiskFileSize_result.class, metaDataMap);
        }

        public getDiskFileSize_result()
        {
        }

        public getDiskFileSize_result(final long success, final RimpException re)
        {
            this();
            this.success = success;
            setSuccessIsSet(true);
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getDiskFileSize_result(final getDiskFileSize_result other)
        {
            __isset_bit_vector.clear();
            __isset_bit_vector.or(other.__isset_bit_vector);
            this.success = other.success;
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public getDiskFileSize_result deepCopy()
        {
            return new getDiskFileSize_result(this);
        }

        @Override
        @Deprecated
        public getDiskFileSize_result clone()
        {
            return new getDiskFileSize_result(this);
        }

        public long getSuccess()
        {
            return this.success;
        }

        public getDiskFileSize_result setSuccess(final long success)
        {
            this.success = success;
            setSuccessIsSet(true);
            return this;
        }

        public void unsetSuccess()
        {
            __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
        }

        /** Returns true if field success is set (has been asigned a value) and false otherwise */
        public boolean isSetSuccess()
        {
            return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
        }

        public void setSuccessIsSet(final boolean value)
        {
            __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public getDiskFileSize_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case SUCCESS:
                    if (value == null)
                    {
                        unsetSuccess();
                    }
                    else
                    {
                        setSuccess((Long) value);
                    }
                    break;

                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return new Long(getSuccess());

                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return isSetSuccess();
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getDiskFileSize_result)
            {
                return this.equals((getDiskFileSize_result) that);
            }
            return false;
        }

        public boolean equals(final getDiskFileSize_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_success = true;
            boolean that_present_success = true;
            if (this_present_success || that_present_success)
            {
                if (!(this_present_success && that_present_success))
                {
                    return false;
                }
                if (this.success != that.success)
                {
                    return false;
                }
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getDiskFileSize_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getDiskFileSize_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(success, typedOther.success);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case SUCCESS:
                            if (field.type == TType.I64)
                            {
                                this.success = iprot.readI64();
                                setSuccessIsSet(true);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess())
            {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                oprot.writeI64(this.success);
                oprot.writeFieldEnd();
            }
            else if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getDiskFileSize_result(");
            boolean first = true;

            sb.append("success:");
            sb.append(this.success);
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getDatastores_args implements TBase<getDatastores_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<getDatastores_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getDatastores_args");

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            ;

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getDatastores_args.class, metaDataMap);
        }

        public getDatastores_args()
        {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getDatastores_args(final getDatastores_args other)
        {
        }

        @Override
        public getDatastores_args deepCopy()
        {
            return new getDatastores_args(this);
        }

        @Override
        @Deprecated
        public getDatastores_args clone()
        {
            return new getDatastores_args(this);
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getDatastores_args)
            {
                return this.equals((getDatastores_args) that);
            }
            return false;
        }

        public boolean equals(final getDatastores_args that)
        {
            if (that == null)
            {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getDatastores_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getDatastores_args typedOther = other;

            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getDatastores_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getDatastores_result implements TBase<getDatastores_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<getDatastores_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getDatastores_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success",
            TType.LIST,
            (short) 0);

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public List<Datastore> success;

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            SUCCESS((short) 0, "success"), RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.SUCCESS, new FieldMetaData("success",
                        TFieldRequirementType.DEFAULT,
                        new ListMetaData(TType.LIST, new StructMetaData(TType.STRUCT,
                            Datastore.class))));
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getDatastores_result.class, metaDataMap);
        }

        public getDatastores_result()
        {
        }

        public getDatastores_result(final List<Datastore> success, final RimpException re)
        {
            this();
            this.success = success;
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getDatastores_result(final getDatastores_result other)
        {
            if (other.isSetSuccess())
            {
                List<Datastore> __this__success = new ArrayList<Datastore>();
                for (Datastore other_element : other.success)
                {
                    __this__success.add(new Datastore(other_element));
                }
                this.success = __this__success;
            }
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public getDatastores_result deepCopy()
        {
            return new getDatastores_result(this);
        }

        @Override
        @Deprecated
        public getDatastores_result clone()
        {
            return new getDatastores_result(this);
        }

        public int getSuccessSize()
        {
            return this.success == null ? 0 : this.success.size();
        }

        public java.util.Iterator<Datastore> getSuccessIterator()
        {
            return this.success == null ? null : this.success.iterator();
        }

        public void addToSuccess(final Datastore elem)
        {
            if (this.success == null)
            {
                this.success = new ArrayList<Datastore>();
            }
            this.success.add(elem);
        }

        public List<Datastore> getSuccess()
        {
            return this.success;
        }

        public getDatastores_result setSuccess(final List<Datastore> success)
        {
            this.success = success;
            return this;
        }

        public void unsetSuccess()
        {
            this.success = null;
        }

        /** Returns true if field success is set (has been asigned a value) and false otherwise */
        public boolean isSetSuccess()
        {
            return this.success != null;
        }

        public void setSuccessIsSet(final boolean value)
        {
            if (!value)
            {
                this.success = null;
            }
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public getDatastores_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case SUCCESS:
                    if (value == null)
                    {
                        unsetSuccess();
                    }
                    else
                    {
                        setSuccess((List<Datastore>) value);
                    }
                    break;

                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return getSuccess();

                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return isSetSuccess();
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getDatastores_result)
            {
                return this.equals((getDatastores_result) that);
            }
            return false;
        }

        public boolean equals(final getDatastores_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success)
            {
                if (!(this_present_success && that_present_success))
                {
                    return false;
                }
                if (!this.success.equals(that.success))
                {
                    return false;
                }
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getDatastores_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getDatastores_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(success, typedOther.success);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case SUCCESS:
                            if (field.type == TType.LIST)
                            {
                                {
                                    TList _list0 = iprot.readListBegin();
                                    this.success = new ArrayList<Datastore>(_list0.size);
                                    for (int _i1 = 0; _i1 < _list0.size; ++_i1)
                                    {
                                        Datastore _elem2;
                                        _elem2 = new Datastore();
                                        _elem2.read(iprot);
                                        this.success.add(_elem2);
                                    }
                                    iprot.readListEnd();
                                }
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess())
            {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                {
                    oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
                    for (Datastore _iter3 : this.success)
                    {
                        _iter3.write(oprot);
                    }
                    oprot.writeListEnd();
                }
                oprot.writeFieldEnd();
            }
            else if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getDatastores_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.success);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getNetInterfaces_args implements TBase<getNetInterfaces_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<getNetInterfaces_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_args");

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            ;

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getNetInterfaces_args.class, metaDataMap);
        }

        public getNetInterfaces_args()
        {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getNetInterfaces_args(final getNetInterfaces_args other)
        {
        }

        @Override
        public getNetInterfaces_args deepCopy()
        {
            return new getNetInterfaces_args(this);
        }

        @Override
        @Deprecated
        public getNetInterfaces_args clone()
        {
            return new getNetInterfaces_args(this);
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getNetInterfaces_args)
            {
                return this.equals((getNetInterfaces_args) that);
            }
            return false;
        }

        public boolean equals(final getNetInterfaces_args that)
        {
            if (that == null)
            {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getNetInterfaces_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getNetInterfaces_args typedOther = other;

            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getNetInterfaces_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getNetInterfaces_result implements TBase<getNetInterfaces_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<getNetInterfaces_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getNetInterfaces_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success",
            TType.LIST,
            (short) 0);

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public List<NetInterface> success;

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            SUCCESS((short) 0, "success"), RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.SUCCESS, new FieldMetaData("success",
                        TFieldRequirementType.DEFAULT,
                        new ListMetaData(TType.LIST, new StructMetaData(TType.STRUCT,
                            NetInterface.class))));
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getNetInterfaces_result.class, metaDataMap);
        }

        public getNetInterfaces_result()
        {
        }

        public getNetInterfaces_result(final List<NetInterface> success, final RimpException re)
        {
            this();
            this.success = success;
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getNetInterfaces_result(final getNetInterfaces_result other)
        {
            if (other.isSetSuccess())
            {
                List<NetInterface> __this__success = new ArrayList<NetInterface>();
                for (NetInterface other_element : other.success)
                {
                    __this__success.add(new NetInterface(other_element));
                }
                this.success = __this__success;
            }
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public getNetInterfaces_result deepCopy()
        {
            return new getNetInterfaces_result(this);
        }

        @Override
        @Deprecated
        public getNetInterfaces_result clone()
        {
            return new getNetInterfaces_result(this);
        }

        public int getSuccessSize()
        {
            return this.success == null ? 0 : this.success.size();
        }

        public java.util.Iterator<NetInterface> getSuccessIterator()
        {
            return this.success == null ? null : this.success.iterator();
        }

        public void addToSuccess(final NetInterface elem)
        {
            if (this.success == null)
            {
                this.success = new ArrayList<NetInterface>();
            }
            this.success.add(elem);
        }

        public List<NetInterface> getSuccess()
        {
            return this.success;
        }

        public getNetInterfaces_result setSuccess(final List<NetInterface> success)
        {
            this.success = success;
            return this;
        }

        public void unsetSuccess()
        {
            this.success = null;
        }

        /** Returns true if field success is set (has been asigned a value) and false otherwise */
        public boolean isSetSuccess()
        {
            return this.success != null;
        }

        public void setSuccessIsSet(final boolean value)
        {
            if (!value)
            {
                this.success = null;
            }
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public getNetInterfaces_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case SUCCESS:
                    if (value == null)
                    {
                        unsetSuccess();
                    }
                    else
                    {
                        setSuccess((List<NetInterface>) value);
                    }
                    break;

                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return getSuccess();

                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return isSetSuccess();
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getNetInterfaces_result)
            {
                return this.equals((getNetInterfaces_result) that);
            }
            return false;
        }

        public boolean equals(final getNetInterfaces_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success)
            {
                if (!(this_present_success && that_present_success))
                {
                    return false;
                }
                if (!this.success.equals(that.success))
                {
                    return false;
                }
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getNetInterfaces_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getNetInterfaces_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(success, typedOther.success);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case SUCCESS:
                            if (field.type == TType.LIST)
                            {
                                {
                                    TList _list4 = iprot.readListBegin();
                                    this.success = new ArrayList<NetInterface>(_list4.size);
                                    for (int _i5 = 0; _i5 < _list4.size; ++_i5)
                                    {
                                        NetInterface _elem6;
                                        _elem6 = new NetInterface();
                                        _elem6.read(iprot);
                                        this.success.add(_elem6);
                                    }
                                    iprot.readListEnd();
                                }
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess())
            {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                {
                    oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
                    for (NetInterface _iter7 : this.success)
                    {
                        _iter7.write(oprot);
                    }
                    oprot.writeListEnd();
                }
                oprot.writeFieldEnd();
            }
            else if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getNetInterfaces_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.success);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class copyFromRepositoryToDatastore_args implements
        TBase<copyFromRepositoryToDatastore_args._Fields>, java.io.Serializable, Cloneable,
        Comparable<copyFromRepositoryToDatastore_args>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("copyFromRepositoryToDatastore_args");

        private static final TField VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC =
            new TField("virtualImageRepositoryPath", TType.STRING, (short) 1);

        private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath",
            TType.STRING,
            (short) 2);

        private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC =
            new TField("virtualMachineUUID", TType.STRING, (short) 3);

        public String virtualImageRepositoryPath;

        public String datastorePath;

        public String virtualMachineUUID;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VIRTUAL_IMAGE_REPOSITORY_PATH((short) 1, "virtualImageRepositoryPath"), DATASTORE_PATH(
                (short) 2, "datastorePath"), VIRTUAL_MACHINE_UUID((short) 3, "virtualMachineUUID");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VIRTUAL_IMAGE_REPOSITORY_PATH,
                        new FieldMetaData("virtualImageRepositoryPath",
                            TFieldRequirementType.DEFAULT,
                            new FieldValueMetaData(TType.STRING)));
                    put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_args.class,
                metaDataMap);
        }

        public copyFromRepositoryToDatastore_args()
        {
        }

        public copyFromRepositoryToDatastore_args(final String virtualImageRepositoryPath,
            final String datastorePath, final String virtualMachineUUID)
        {
            this();
            this.virtualImageRepositoryPath = virtualImageRepositoryPath;
            this.datastorePath = datastorePath;
            this.virtualMachineUUID = virtualMachineUUID;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public copyFromRepositoryToDatastore_args(final copyFromRepositoryToDatastore_args other)
        {
            if (other.isSetVirtualImageRepositoryPath())
            {
                this.virtualImageRepositoryPath = other.virtualImageRepositoryPath;
            }
            if (other.isSetDatastorePath())
            {
                this.datastorePath = other.datastorePath;
            }
            if (other.isSetVirtualMachineUUID())
            {
                this.virtualMachineUUID = other.virtualMachineUUID;
            }
        }

        @Override
        public copyFromRepositoryToDatastore_args deepCopy()
        {
            return new copyFromRepositoryToDatastore_args(this);
        }

        @Override
        @Deprecated
        public copyFromRepositoryToDatastore_args clone()
        {
            return new copyFromRepositoryToDatastore_args(this);
        }

        public String getVirtualImageRepositoryPath()
        {
            return this.virtualImageRepositoryPath;
        }

        public copyFromRepositoryToDatastore_args setVirtualImageRepositoryPath(
            final String virtualImageRepositoryPath)
        {
            this.virtualImageRepositoryPath = virtualImageRepositoryPath;
            return this;
        }

        public void unsetVirtualImageRepositoryPath()
        {
            this.virtualImageRepositoryPath = null;
        }

        /**
         * Returns true if field virtualImageRepositoryPath is set (has been asigned a value) and
         * false otherwise
         */
        public boolean isSetVirtualImageRepositoryPath()
        {
            return this.virtualImageRepositoryPath != null;
        }

        public void setVirtualImageRepositoryPathIsSet(final boolean value)
        {
            if (!value)
            {
                this.virtualImageRepositoryPath = null;
            }
        }

        public String getDatastorePath()
        {
            return this.datastorePath;
        }

        public copyFromRepositoryToDatastore_args setDatastorePath(final String datastorePath)
        {
            this.datastorePath = datastorePath;
            return this;
        }

        public void unsetDatastorePath()
        {
            this.datastorePath = null;
        }

        /**
         * Returns true if field datastorePath is set (has been asigned a value) and false otherwise
         */
        public boolean isSetDatastorePath()
        {
            return this.datastorePath != null;
        }

        public void setDatastorePathIsSet(final boolean value)
        {
            if (!value)
            {
                this.datastorePath = null;
            }
        }

        public String getVirtualMachineUUID()
        {
            return this.virtualMachineUUID;
        }

        public copyFromRepositoryToDatastore_args setVirtualMachineUUID(
            final String virtualMachineUUID)
        {
            this.virtualMachineUUID = virtualMachineUUID;
            return this;
        }

        public void unsetVirtualMachineUUID()
        {
            this.virtualMachineUUID = null;
        }

        /**
         * Returns true if field virtualMachineUUID is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetVirtualMachineUUID()
        {
            return this.virtualMachineUUID != null;
        }

        public void setVirtualMachineUUIDIsSet(final boolean value)
        {
            if (!value)
            {
                this.virtualMachineUUID = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_REPOSITORY_PATH:
                    if (value == null)
                    {
                        unsetVirtualImageRepositoryPath();
                    }
                    else
                    {
                        setVirtualImageRepositoryPath((String) value);
                    }
                    break;

                case DATASTORE_PATH:
                    if (value == null)
                    {
                        unsetDatastorePath();
                    }
                    else
                    {
                        setDatastorePath((String) value);
                    }
                    break;

                case VIRTUAL_MACHINE_UUID:
                    if (value == null)
                    {
                        unsetVirtualMachineUUID();
                    }
                    else
                    {
                        setVirtualMachineUUID((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_REPOSITORY_PATH:
                    return getVirtualImageRepositoryPath();

                case DATASTORE_PATH:
                    return getDatastorePath();

                case VIRTUAL_MACHINE_UUID:
                    return getVirtualMachineUUID();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_IMAGE_REPOSITORY_PATH:
                    return isSetVirtualImageRepositoryPath();
                case DATASTORE_PATH:
                    return isSetDatastorePath();
                case VIRTUAL_MACHINE_UUID:
                    return isSetVirtualMachineUUID();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof copyFromRepositoryToDatastore_args)
            {
                return this.equals((copyFromRepositoryToDatastore_args) that);
            }
            return false;
        }

        public boolean equals(final copyFromRepositoryToDatastore_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_virtualImageRepositoryPath =
                true && this.isSetVirtualImageRepositoryPath();
            boolean that_present_virtualImageRepositoryPath =
                true && that.isSetVirtualImageRepositoryPath();
            if (this_present_virtualImageRepositoryPath || that_present_virtualImageRepositoryPath)
            {
                if (!(this_present_virtualImageRepositoryPath && that_present_virtualImageRepositoryPath))
                {
                    return false;
                }
                if (!this.virtualImageRepositoryPath.equals(that.virtualImageRepositoryPath))
                {
                    return false;
                }
            }

            boolean this_present_datastorePath = true && this.isSetDatastorePath();
            boolean that_present_datastorePath = true && that.isSetDatastorePath();
            if (this_present_datastorePath || that_present_datastorePath)
            {
                if (!(this_present_datastorePath && that_present_datastorePath))
                {
                    return false;
                }
                if (!this.datastorePath.equals(that.datastorePath))
                {
                    return false;
                }
            }

            boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
            boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
            if (this_present_virtualMachineUUID || that_present_virtualMachineUUID)
            {
                if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
                {
                    return false;
                }
                if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final copyFromRepositoryToDatastore_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            copyFromRepositoryToDatastore_args typedOther = other;

            lastComparison =
                Boolean.valueOf(isSetVirtualImageRepositoryPath()).compareTo(
                    isSetVirtualImageRepositoryPath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(virtualImageRepositoryPath,
                    typedOther.virtualImageRepositoryPath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(isSetDatastorePath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(datastorePath, typedOther.datastorePath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VIRTUAL_IMAGE_REPOSITORY_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.virtualImageRepositoryPath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case DATASTORE_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.datastorePath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case VIRTUAL_MACHINE_UUID:
                            if (field.type == TType.STRING)
                            {
                                this.virtualMachineUUID = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.virtualImageRepositoryPath != null)
            {
                oprot.writeFieldBegin(VIRTUAL_IMAGE_REPOSITORY_PATH_FIELD_DESC);
                oprot.writeString(this.virtualImageRepositoryPath);
                oprot.writeFieldEnd();
            }
            if (this.datastorePath != null)
            {
                oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
                oprot.writeString(this.datastorePath);
                oprot.writeFieldEnd();
            }
            if (this.virtualMachineUUID != null)
            {
                oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
                oprot.writeString(this.virtualMachineUUID);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_args(");
            boolean first = true;

            sb.append("virtualImageRepositoryPath:");
            if (this.virtualImageRepositoryPath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.virtualImageRepositoryPath);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("datastorePath:");
            if (this.datastorePath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.datastorePath);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("virtualMachineUUID:");
            if (this.virtualMachineUUID == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.virtualMachineUUID);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class copyFromRepositoryToDatastore_result implements
        TBase<copyFromRepositoryToDatastore_result._Fields>, java.io.Serializable, Cloneable,
        Comparable<copyFromRepositoryToDatastore_result>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("copyFromRepositoryToDatastore_result");

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(copyFromRepositoryToDatastore_result.class,
                metaDataMap);
        }

        public copyFromRepositoryToDatastore_result()
        {
        }

        public copyFromRepositoryToDatastore_result(final RimpException re)
        {
            this();
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public copyFromRepositoryToDatastore_result(final copyFromRepositoryToDatastore_result other)
        {
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public copyFromRepositoryToDatastore_result deepCopy()
        {
            return new copyFromRepositoryToDatastore_result(this);
        }

        @Override
        @Deprecated
        public copyFromRepositoryToDatastore_result clone()
        {
            return new copyFromRepositoryToDatastore_result(this);
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public copyFromRepositoryToDatastore_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof copyFromRepositoryToDatastore_result)
            {
                return this.equals((copyFromRepositoryToDatastore_result) that);
            }
            return false;
        }

        public boolean equals(final copyFromRepositoryToDatastore_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final copyFromRepositoryToDatastore_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            copyFromRepositoryToDatastore_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("copyFromRepositoryToDatastore_result(");
            boolean first = true;

            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class deleteVirtualImageFromDatastore_args implements
        TBase<deleteVirtualImageFromDatastore_args._Fields>, java.io.Serializable, Cloneable,
        Comparable<deleteVirtualImageFromDatastore_args>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("deleteVirtualImageFromDatastore_args");

        private static final TField DATASTORE_PATH_FIELD_DESC = new TField("datastorePath",
            TType.STRING,
            (short) 1);

        private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC =
            new TField("virtualMachineUUID", TType.STRING, (short) 2);

        public String datastorePath;

        public String virtualMachineUUID;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            DATASTORE_PATH((short) 1, "datastorePath"), VIRTUAL_MACHINE_UUID((short) 2,
                "virtualMachineUUID");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.DATASTORE_PATH, new FieldMetaData("datastorePath",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_args.class,
                metaDataMap);
        }

        public deleteVirtualImageFromDatastore_args()
        {
        }

        public deleteVirtualImageFromDatastore_args(final String datastorePath,
            final String virtualMachineUUID)
        {
            this();
            this.datastorePath = datastorePath;
            this.virtualMachineUUID = virtualMachineUUID;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public deleteVirtualImageFromDatastore_args(final deleteVirtualImageFromDatastore_args other)
        {
            if (other.isSetDatastorePath())
            {
                this.datastorePath = other.datastorePath;
            }
            if (other.isSetVirtualMachineUUID())
            {
                this.virtualMachineUUID = other.virtualMachineUUID;
            }
        }

        @Override
        public deleteVirtualImageFromDatastore_args deepCopy()
        {
            return new deleteVirtualImageFromDatastore_args(this);
        }

        @Override
        @Deprecated
        public deleteVirtualImageFromDatastore_args clone()
        {
            return new deleteVirtualImageFromDatastore_args(this);
        }

        public String getDatastorePath()
        {
            return this.datastorePath;
        }

        public deleteVirtualImageFromDatastore_args setDatastorePath(final String datastorePath)
        {
            this.datastorePath = datastorePath;
            return this;
        }

        public void unsetDatastorePath()
        {
            this.datastorePath = null;
        }

        /**
         * Returns true if field datastorePath is set (has been asigned a value) and false otherwise
         */
        public boolean isSetDatastorePath()
        {
            return this.datastorePath != null;
        }

        public void setDatastorePathIsSet(final boolean value)
        {
            if (!value)
            {
                this.datastorePath = null;
            }
        }

        public String getVirtualMachineUUID()
        {
            return this.virtualMachineUUID;
        }

        public deleteVirtualImageFromDatastore_args setVirtualMachineUUID(
            final String virtualMachineUUID)
        {
            this.virtualMachineUUID = virtualMachineUUID;
            return this;
        }

        public void unsetVirtualMachineUUID()
        {
            this.virtualMachineUUID = null;
        }

        /**
         * Returns true if field virtualMachineUUID is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetVirtualMachineUUID()
        {
            return this.virtualMachineUUID != null;
        }

        public void setVirtualMachineUUIDIsSet(final boolean value)
        {
            if (!value)
            {
                this.virtualMachineUUID = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case DATASTORE_PATH:
                    if (value == null)
                    {
                        unsetDatastorePath();
                    }
                    else
                    {
                        setDatastorePath((String) value);
                    }
                    break;

                case VIRTUAL_MACHINE_UUID:
                    if (value == null)
                    {
                        unsetVirtualMachineUUID();
                    }
                    else
                    {
                        setVirtualMachineUUID((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case DATASTORE_PATH:
                    return getDatastorePath();

                case VIRTUAL_MACHINE_UUID:
                    return getVirtualMachineUUID();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case DATASTORE_PATH:
                    return isSetDatastorePath();
                case VIRTUAL_MACHINE_UUID:
                    return isSetVirtualMachineUUID();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof deleteVirtualImageFromDatastore_args)
            {
                return this.equals((deleteVirtualImageFromDatastore_args) that);
            }
            return false;
        }

        public boolean equals(final deleteVirtualImageFromDatastore_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_datastorePath = true && this.isSetDatastorePath();
            boolean that_present_datastorePath = true && that.isSetDatastorePath();
            if (this_present_datastorePath || that_present_datastorePath)
            {
                if (!(this_present_datastorePath && that_present_datastorePath))
                {
                    return false;
                }
                if (!this.datastorePath.equals(that.datastorePath))
                {
                    return false;
                }
            }

            boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
            boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
            if (this_present_virtualMachineUUID || that_present_virtualMachineUUID)
            {
                if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
                {
                    return false;
                }
                if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final deleteVirtualImageFromDatastore_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            deleteVirtualImageFromDatastore_args typedOther = other;

            lastComparison = Boolean.valueOf(isSetDatastorePath()).compareTo(isSetDatastorePath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(datastorePath, typedOther.datastorePath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case DATASTORE_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.datastorePath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case VIRTUAL_MACHINE_UUID:
                            if (field.type == TType.STRING)
                            {
                                this.virtualMachineUUID = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.datastorePath != null)
            {
                oprot.writeFieldBegin(DATASTORE_PATH_FIELD_DESC);
                oprot.writeString(this.datastorePath);
                oprot.writeFieldEnd();
            }
            if (this.virtualMachineUUID != null)
            {
                oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
                oprot.writeString(this.virtualMachineUUID);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_args(");
            boolean first = true;

            sb.append("datastorePath:");
            if (this.datastorePath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.datastorePath);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("virtualMachineUUID:");
            if (this.virtualMachineUUID == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.virtualMachineUUID);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class deleteVirtualImageFromDatastore_result implements
        TBase<deleteVirtualImageFromDatastore_result._Fields>, java.io.Serializable, Cloneable,
        Comparable<deleteVirtualImageFromDatastore_result>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("deleteVirtualImageFromDatastore_result");

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(deleteVirtualImageFromDatastore_result.class,
                metaDataMap);
        }

        public deleteVirtualImageFromDatastore_result()
        {
        }

        public deleteVirtualImageFromDatastore_result(final RimpException re)
        {
            this();
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public deleteVirtualImageFromDatastore_result(
            final deleteVirtualImageFromDatastore_result other)
        {
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public deleteVirtualImageFromDatastore_result deepCopy()
        {
            return new deleteVirtualImageFromDatastore_result(this);
        }

        @Override
        @Deprecated
        public deleteVirtualImageFromDatastore_result clone()
        {
            return new deleteVirtualImageFromDatastore_result(this);
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public deleteVirtualImageFromDatastore_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof deleteVirtualImageFromDatastore_result)
            {
                return this.equals((deleteVirtualImageFromDatastore_result) that);
            }
            return false;
        }

        public boolean equals(final deleteVirtualImageFromDatastore_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final deleteVirtualImageFromDatastore_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            deleteVirtualImageFromDatastore_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("deleteVirtualImageFromDatastore_result(");
            boolean first = true;

            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class copyFromDatastoreToRepository_args implements
        TBase<copyFromDatastoreToRepository_args._Fields>, java.io.Serializable, Cloneable,
        Comparable<copyFromDatastoreToRepository_args>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("copyFromDatastoreToRepository_args");

        private static final TField VIRTUAL_MACHINE_UUID_FIELD_DESC =
            new TField("virtualMachineUUID", TType.STRING, (short) 1);

        private static final TField SNAPSHOT_FIELD_DESC = new TField("snapshot",
            TType.STRING,
            (short) 2);

        private static final TField DESTINATION_REPOSITORY_PATH_FIELD_DESC =
            new TField("destinationRepositoryPath", TType.STRING, (short) 3);

        private static final TField SOURCE_DATASTORE_PATH_FIELD_DESC =
            new TField("sourceDatastorePath", TType.STRING, (short) 4);

        public String virtualMachineUUID;

        public String snapshot;

        public String destinationRepositoryPath;

        public String sourceDatastorePath;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VIRTUAL_MACHINE_UUID((short) 1, "virtualMachineUUID"), SNAPSHOT((short) 2, "snapshot"), DESTINATION_REPOSITORY_PATH(
                (short) 3, "destinationRepositoryPath"), SOURCE_DATASTORE_PATH((short) 4,
                "sourceDatastorePath");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VIRTUAL_MACHINE_UUID, new FieldMetaData("virtualMachineUUID",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.SNAPSHOT, new FieldMetaData("snapshot",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.DESTINATION_REPOSITORY_PATH,
                        new FieldMetaData("destinationRepositoryPath",
                            TFieldRequirementType.DEFAULT,
                            new FieldValueMetaData(TType.STRING)));
                    put(_Fields.SOURCE_DATASTORE_PATH, new FieldMetaData("sourceDatastorePath",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_args.class,
                metaDataMap);
        }

        public copyFromDatastoreToRepository_args()
        {
        }

        public copyFromDatastoreToRepository_args(final String virtualMachineUUID,
            final String snapshot, final String destinationRepositoryPath,
            final String sourceDatastorePath)
        {
            this();
            this.virtualMachineUUID = virtualMachineUUID;
            this.snapshot = snapshot;
            this.destinationRepositoryPath = destinationRepositoryPath;
            this.sourceDatastorePath = sourceDatastorePath;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public copyFromDatastoreToRepository_args(final copyFromDatastoreToRepository_args other)
        {
            if (other.isSetVirtualMachineUUID())
            {
                this.virtualMachineUUID = other.virtualMachineUUID;
            }
            if (other.isSetSnapshot())
            {
                this.snapshot = other.snapshot;
            }
            if (other.isSetDestinationRepositoryPath())
            {
                this.destinationRepositoryPath = other.destinationRepositoryPath;
            }
            if (other.isSetSourceDatastorePath())
            {
                this.sourceDatastorePath = other.sourceDatastorePath;
            }
        }

        @Override
        public copyFromDatastoreToRepository_args deepCopy()
        {
            return new copyFromDatastoreToRepository_args(this);
        }

        @Override
        @Deprecated
        public copyFromDatastoreToRepository_args clone()
        {
            return new copyFromDatastoreToRepository_args(this);
        }

        public String getVirtualMachineUUID()
        {
            return this.virtualMachineUUID;
        }

        public copyFromDatastoreToRepository_args setVirtualMachineUUID(
            final String virtualMachineUUID)
        {
            this.virtualMachineUUID = virtualMachineUUID;
            return this;
        }

        public void unsetVirtualMachineUUID()
        {
            this.virtualMachineUUID = null;
        }

        /**
         * Returns true if field virtualMachineUUID is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetVirtualMachineUUID()
        {
            return this.virtualMachineUUID != null;
        }

        public void setVirtualMachineUUIDIsSet(final boolean value)
        {
            if (!value)
            {
                this.virtualMachineUUID = null;
            }
        }

        public String getSnapshot()
        {
            return this.snapshot;
        }

        public copyFromDatastoreToRepository_args setSnapshot(final String snapshot)
        {
            this.snapshot = snapshot;
            return this;
        }

        public void unsetSnapshot()
        {
            this.snapshot = null;
        }

        /** Returns true if field snapshot is set (has been asigned a value) and false otherwise */
        public boolean isSetSnapshot()
        {
            return this.snapshot != null;
        }

        public void setSnapshotIsSet(final boolean value)
        {
            if (!value)
            {
                this.snapshot = null;
            }
        }

        public String getDestinationRepositoryPath()
        {
            return this.destinationRepositoryPath;
        }

        public copyFromDatastoreToRepository_args setDestinationRepositoryPath(
            final String destinationRepositoryPath)
        {
            this.destinationRepositoryPath = destinationRepositoryPath;
            return this;
        }

        public void unsetDestinationRepositoryPath()
        {
            this.destinationRepositoryPath = null;
        }

        /**
         * Returns true if field destinationRepositoryPath is set (has been asigned a value) and
         * false otherwise
         */
        public boolean isSetDestinationRepositoryPath()
        {
            return this.destinationRepositoryPath != null;
        }

        public void setDestinationRepositoryPathIsSet(final boolean value)
        {
            if (!value)
            {
                this.destinationRepositoryPath = null;
            }
        }

        public String getSourceDatastorePath()
        {
            return this.sourceDatastorePath;
        }

        public copyFromDatastoreToRepository_args setSourceDatastorePath(
            final String sourceDatastorePath)
        {
            this.sourceDatastorePath = sourceDatastorePath;
            return this;
        }

        public void unsetSourceDatastorePath()
        {
            this.sourceDatastorePath = null;
        }

        /**
         * Returns true if field sourceDatastorePath is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetSourceDatastorePath()
        {
            return this.sourceDatastorePath != null;
        }

        public void setSourceDatastorePathIsSet(final boolean value)
        {
            if (!value)
            {
                this.sourceDatastorePath = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VIRTUAL_MACHINE_UUID:
                    if (value == null)
                    {
                        unsetVirtualMachineUUID();
                    }
                    else
                    {
                        setVirtualMachineUUID((String) value);
                    }
                    break;

                case SNAPSHOT:
                    if (value == null)
                    {
                        unsetSnapshot();
                    }
                    else
                    {
                        setSnapshot((String) value);
                    }
                    break;

                case DESTINATION_REPOSITORY_PATH:
                    if (value == null)
                    {
                        unsetDestinationRepositoryPath();
                    }
                    else
                    {
                        setDestinationRepositoryPath((String) value);
                    }
                    break;

                case SOURCE_DATASTORE_PATH:
                    if (value == null)
                    {
                        unsetSourceDatastorePath();
                    }
                    else
                    {
                        setSourceDatastorePath((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_MACHINE_UUID:
                    return getVirtualMachineUUID();

                case SNAPSHOT:
                    return getSnapshot();

                case DESTINATION_REPOSITORY_PATH:
                    return getDestinationRepositoryPath();

                case SOURCE_DATASTORE_PATH:
                    return getSourceDatastorePath();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VIRTUAL_MACHINE_UUID:
                    return isSetVirtualMachineUUID();
                case SNAPSHOT:
                    return isSetSnapshot();
                case DESTINATION_REPOSITORY_PATH:
                    return isSetDestinationRepositoryPath();
                case SOURCE_DATASTORE_PATH:
                    return isSetSourceDatastorePath();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof copyFromDatastoreToRepository_args)
            {
                return this.equals((copyFromDatastoreToRepository_args) that);
            }
            return false;
        }

        public boolean equals(final copyFromDatastoreToRepository_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_virtualMachineUUID = true && this.isSetVirtualMachineUUID();
            boolean that_present_virtualMachineUUID = true && that.isSetVirtualMachineUUID();
            if (this_present_virtualMachineUUID || that_present_virtualMachineUUID)
            {
                if (!(this_present_virtualMachineUUID && that_present_virtualMachineUUID))
                {
                    return false;
                }
                if (!this.virtualMachineUUID.equals(that.virtualMachineUUID))
                {
                    return false;
                }
            }

            boolean this_present_snapshot = true && this.isSetSnapshot();
            boolean that_present_snapshot = true && that.isSetSnapshot();
            if (this_present_snapshot || that_present_snapshot)
            {
                if (!(this_present_snapshot && that_present_snapshot))
                {
                    return false;
                }
                if (!this.snapshot.equals(that.snapshot))
                {
                    return false;
                }
            }

            boolean this_present_destinationRepositoryPath =
                true && this.isSetDestinationRepositoryPath();
            boolean that_present_destinationRepositoryPath =
                true && that.isSetDestinationRepositoryPath();
            if (this_present_destinationRepositoryPath || that_present_destinationRepositoryPath)
            {
                if (!(this_present_destinationRepositoryPath && that_present_destinationRepositoryPath))
                {
                    return false;
                }
                if (!this.destinationRepositoryPath.equals(that.destinationRepositoryPath))
                {
                    return false;
                }
            }

            boolean this_present_sourceDatastorePath = true && this.isSetSourceDatastorePath();
            boolean that_present_sourceDatastorePath = true && that.isSetSourceDatastorePath();
            if (this_present_sourceDatastorePath || that_present_sourceDatastorePath)
            {
                if (!(this_present_sourceDatastorePath && that_present_sourceDatastorePath))
                {
                    return false;
                }
                if (!this.sourceDatastorePath.equals(that.sourceDatastorePath))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final copyFromDatastoreToRepository_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            copyFromDatastoreToRepository_args typedOther = other;

            lastComparison =
                Boolean.valueOf(isSetVirtualMachineUUID()).compareTo(isSetVirtualMachineUUID());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(virtualMachineUUID, typedOther.virtualMachineUUID);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetSnapshot()).compareTo(isSetSnapshot());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(snapshot, typedOther.snapshot);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetDestinationRepositoryPath()).compareTo(
                    isSetDestinationRepositoryPath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(destinationRepositoryPath,
                    typedOther.destinationRepositoryPath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetSourceDatastorePath()).compareTo(isSetSourceDatastorePath());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                TBaseHelper.compareTo(sourceDatastorePath, typedOther.sourceDatastorePath);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VIRTUAL_MACHINE_UUID:
                            if (field.type == TType.STRING)
                            {
                                this.virtualMachineUUID = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case SNAPSHOT:
                            if (field.type == TType.STRING)
                            {
                                this.snapshot = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case DESTINATION_REPOSITORY_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.destinationRepositoryPath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case SOURCE_DATASTORE_PATH:
                            if (field.type == TType.STRING)
                            {
                                this.sourceDatastorePath = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.virtualMachineUUID != null)
            {
                oprot.writeFieldBegin(VIRTUAL_MACHINE_UUID_FIELD_DESC);
                oprot.writeString(this.virtualMachineUUID);
                oprot.writeFieldEnd();
            }
            if (this.snapshot != null)
            {
                oprot.writeFieldBegin(SNAPSHOT_FIELD_DESC);
                oprot.writeString(this.snapshot);
                oprot.writeFieldEnd();
            }
            if (this.destinationRepositoryPath != null)
            {
                oprot.writeFieldBegin(DESTINATION_REPOSITORY_PATH_FIELD_DESC);
                oprot.writeString(this.destinationRepositoryPath);
                oprot.writeFieldEnd();
            }
            if (this.sourceDatastorePath != null)
            {
                oprot.writeFieldBegin(SOURCE_DATASTORE_PATH_FIELD_DESC);
                oprot.writeString(this.sourceDatastorePath);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_args(");
            boolean first = true;

            sb.append("virtualMachineUUID:");
            if (this.virtualMachineUUID == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.virtualMachineUUID);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("snapshot:");
            if (this.snapshot == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.snapshot);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("destinationRepositoryPath:");
            if (this.destinationRepositoryPath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.destinationRepositoryPath);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("sourceDatastorePath:");
            if (this.sourceDatastorePath == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.sourceDatastorePath);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class copyFromDatastoreToRepository_result implements
        TBase<copyFromDatastoreToRepository_result._Fields>, java.io.Serializable, Cloneable,
        Comparable<copyFromDatastoreToRepository_result>
    {
        private static final TStruct STRUCT_DESC =
            new TStruct("copyFromDatastoreToRepository_result");

        private static final TField RE_FIELD_DESC = new TField("re", TType.STRUCT, (short) 1);

        public RimpException re;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            RE((short) 1, "re");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.RE, new FieldMetaData("re",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(copyFromDatastoreToRepository_result.class,
                metaDataMap);
        }

        public copyFromDatastoreToRepository_result()
        {
        }

        public copyFromDatastoreToRepository_result(final RimpException re)
        {
            this();
            this.re = re;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public copyFromDatastoreToRepository_result(final copyFromDatastoreToRepository_result other)
        {
            if (other.isSetRe())
            {
                this.re = new RimpException(other.re);
            }
        }

        @Override
        public copyFromDatastoreToRepository_result deepCopy()
        {
            return new copyFromDatastoreToRepository_result(this);
        }

        @Override
        @Deprecated
        public copyFromDatastoreToRepository_result clone()
        {
            return new copyFromDatastoreToRepository_result(this);
        }

        public RimpException getRe()
        {
            return this.re;
        }

        public copyFromDatastoreToRepository_result setRe(final RimpException re)
        {
            this.re = re;
            return this;
        }

        public void unsetRe()
        {
            this.re = null;
        }

        /** Returns true if field re is set (has been asigned a value) and false otherwise */
        public boolean isSetRe()
        {
            return this.re != null;
        }

        public void setReIsSet(final boolean value)
        {
            if (!value)
            {
                this.re = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case RE:
                    if (value == null)
                    {
                        unsetRe();
                    }
                    else
                    {
                        setRe((RimpException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return getRe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case RE:
                    return isSetRe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof copyFromDatastoreToRepository_result)
            {
                return this.equals((copyFromDatastoreToRepository_result) that);
            }
            return false;
        }

        public boolean equals(final copyFromDatastoreToRepository_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_re = true && this.isSetRe();
            boolean that_present_re = true && that.isSetRe();
            if (this_present_re || that_present_re)
            {
                if (!(this_present_re && that_present_re))
                {
                    return false;
                }
                if (!this.re.equals(that.re))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final copyFromDatastoreToRepository_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            copyFromDatastoreToRepository_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetRe()).compareTo(isSetRe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(re, typedOther.re);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case RE:
                            if (field.type == TType.STRUCT)
                            {
                                this.re = new RimpException();
                                this.re.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetRe())
            {
                oprot.writeFieldBegin(RE_FIELD_DESC);
                this.re.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("copyFromDatastoreToRepository_result(");
            boolean first = true;

            sb.append("re:");
            if (this.re == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.re);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class createVLAN_args implements TBase<createVLAN_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<createVLAN_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("createVLAN_args");

        private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag",
            TType.I32,
            (short) 1);

        private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface",
            TType.STRING,
            (short) 2);

        private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface",
            TType.STRING,
            (short) 3);

        public int vlanTag;

        public String vlanInterface;

        public String bridgeInterface;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VLAN_TAG((short) 1, "vlanTag"), VLAN_INTERFACE((short) 2, "vlanInterface"), BRIDGE_INTERFACE(
                (short) 3, "bridgeInterface");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments
        private static final int __VLANTAG_ISSET_ID = 0;

        private BitSet __isset_bit_vector = new BitSet(1);

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.I32)));
                    put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(createVLAN_args.class, metaDataMap);
        }

        public createVLAN_args()
        {
        }

        public createVLAN_args(final int vlanTag, final String vlanInterface,
            final String bridgeInterface)
        {
            this();
            this.vlanTag = vlanTag;
            setVlanTagIsSet(true);
            this.vlanInterface = vlanInterface;
            this.bridgeInterface = bridgeInterface;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public createVLAN_args(final createVLAN_args other)
        {
            __isset_bit_vector.clear();
            __isset_bit_vector.or(other.__isset_bit_vector);
            this.vlanTag = other.vlanTag;
            if (other.isSetVlanInterface())
            {
                this.vlanInterface = other.vlanInterface;
            }
            if (other.isSetBridgeInterface())
            {
                this.bridgeInterface = other.bridgeInterface;
            }
        }

        @Override
        public createVLAN_args deepCopy()
        {
            return new createVLAN_args(this);
        }

        @Override
        @Deprecated
        public createVLAN_args clone()
        {
            return new createVLAN_args(this);
        }

        public int getVlanTag()
        {
            return this.vlanTag;
        }

        public createVLAN_args setVlanTag(final int vlanTag)
        {
            this.vlanTag = vlanTag;
            setVlanTagIsSet(true);
            return this;
        }

        public void unsetVlanTag()
        {
            __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
        }

        /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
        public boolean isSetVlanTag()
        {
            return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
        }

        public void setVlanTagIsSet(final boolean value)
        {
            __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
        }

        public String getVlanInterface()
        {
            return this.vlanInterface;
        }

        public createVLAN_args setVlanInterface(final String vlanInterface)
        {
            this.vlanInterface = vlanInterface;
            return this;
        }

        public void unsetVlanInterface()
        {
            this.vlanInterface = null;
        }

        /**
         * Returns true if field vlanInterface is set (has been asigned a value) and false otherwise
         */
        public boolean isSetVlanInterface()
        {
            return this.vlanInterface != null;
        }

        public void setVlanInterfaceIsSet(final boolean value)
        {
            if (!value)
            {
                this.vlanInterface = null;
            }
        }

        public String getBridgeInterface()
        {
            return this.bridgeInterface;
        }

        public createVLAN_args setBridgeInterface(final String bridgeInterface)
        {
            this.bridgeInterface = bridgeInterface;
            return this;
        }

        public void unsetBridgeInterface()
        {
            this.bridgeInterface = null;
        }

        /**
         * Returns true if field bridgeInterface is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetBridgeInterface()
        {
            return this.bridgeInterface != null;
        }

        public void setBridgeInterfaceIsSet(final boolean value)
        {
            if (!value)
            {
                this.bridgeInterface = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VLAN_TAG:
                    if (value == null)
                    {
                        unsetVlanTag();
                    }
                    else
                    {
                        setVlanTag((Integer) value);
                    }
                    break;

                case VLAN_INTERFACE:
                    if (value == null)
                    {
                        unsetVlanInterface();
                    }
                    else
                    {
                        setVlanInterface((String) value);
                    }
                    break;

                case BRIDGE_INTERFACE:
                    if (value == null)
                    {
                        unsetBridgeInterface();
                    }
                    else
                    {
                        setBridgeInterface((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VLAN_TAG:
                    return new Integer(getVlanTag());

                case VLAN_INTERFACE:
                    return getVlanInterface();

                case BRIDGE_INTERFACE:
                    return getBridgeInterface();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VLAN_TAG:
                    return isSetVlanTag();
                case VLAN_INTERFACE:
                    return isSetVlanInterface();
                case BRIDGE_INTERFACE:
                    return isSetBridgeInterface();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof createVLAN_args)
            {
                return this.equals((createVLAN_args) that);
            }
            return false;
        }

        public boolean equals(final createVLAN_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_vlanTag = true;
            boolean that_present_vlanTag = true;
            if (this_present_vlanTag || that_present_vlanTag)
            {
                if (!(this_present_vlanTag && that_present_vlanTag))
                {
                    return false;
                }
                if (this.vlanTag != that.vlanTag)
                {
                    return false;
                }
            }

            boolean this_present_vlanInterface = true && this.isSetVlanInterface();
            boolean that_present_vlanInterface = true && that.isSetVlanInterface();
            if (this_present_vlanInterface || that_present_vlanInterface)
            {
                if (!(this_present_vlanInterface && that_present_vlanInterface))
                {
                    return false;
                }
                if (!this.vlanInterface.equals(that.vlanInterface))
                {
                    return false;
                }
            }

            boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
            boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
            if (this_present_bridgeInterface || that_present_bridgeInterface)
            {
                if (!(this_present_bridgeInterface && that_present_bridgeInterface))
                {
                    return false;
                }
                if (!this.bridgeInterface.equals(that.bridgeInterface))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final createVLAN_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            createVLAN_args typedOther = other;

            lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(isSetVlanTag());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(vlanTag, typedOther.vlanTag);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(isSetVlanInterface());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(vlanInterface, typedOther.vlanInterface);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetBridgeInterface()).compareTo(isSetBridgeInterface());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(bridgeInterface, typedOther.bridgeInterface);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VLAN_TAG:
                            if (field.type == TType.I32)
                            {
                                this.vlanTag = iprot.readI32();
                                setVlanTagIsSet(true);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case VLAN_INTERFACE:
                            if (field.type == TType.STRING)
                            {
                                this.vlanInterface = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case BRIDGE_INTERFACE:
                            if (field.type == TType.STRING)
                            {
                                this.bridgeInterface = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
            oprot.writeI32(this.vlanTag);
            oprot.writeFieldEnd();
            if (this.vlanInterface != null)
            {
                oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
                oprot.writeString(this.vlanInterface);
                oprot.writeFieldEnd();
            }
            if (this.bridgeInterface != null)
            {
                oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
                oprot.writeString(this.bridgeInterface);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("createVLAN_args(");
            boolean first = true;

            sb.append("vlanTag:");
            sb.append(this.vlanTag);
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("vlanInterface:");
            if (this.vlanInterface == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.vlanInterface);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("bridgeInterface:");
            if (this.bridgeInterface == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.bridgeInterface);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class createVLAN_result implements TBase<createVLAN_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<createVLAN_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("createVLAN_result");

        private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short) 1);

        public VLanException ve;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VE((short) 1, "ve");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VE, new FieldMetaData("ve",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(createVLAN_result.class, metaDataMap);
        }

        public createVLAN_result()
        {
        }

        public createVLAN_result(final VLanException ve)
        {
            this();
            this.ve = ve;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public createVLAN_result(final createVLAN_result other)
        {
            if (other.isSetVe())
            {
                this.ve = new VLanException(other.ve);
            }
        }

        @Override
        public createVLAN_result deepCopy()
        {
            return new createVLAN_result(this);
        }

        @Override
        @Deprecated
        public createVLAN_result clone()
        {
            return new createVLAN_result(this);
        }

        public VLanException getVe()
        {
            return this.ve;
        }

        public createVLAN_result setVe(final VLanException ve)
        {
            this.ve = ve;
            return this;
        }

        public void unsetVe()
        {
            this.ve = null;
        }

        /** Returns true if field ve is set (has been asigned a value) and false otherwise */
        public boolean isSetVe()
        {
            return this.ve != null;
        }

        public void setVeIsSet(final boolean value)
        {
            if (!value)
            {
                this.ve = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VE:
                    if (value == null)
                    {
                        unsetVe();
                    }
                    else
                    {
                        setVe((VLanException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return getVe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return isSetVe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof createVLAN_result)
            {
                return this.equals((createVLAN_result) that);
            }
            return false;
        }

        public boolean equals(final createVLAN_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_ve = true && this.isSetVe();
            boolean that_present_ve = true && that.isSetVe();
            if (this_present_ve || that_present_ve)
            {
                if (!(this_present_ve && that_present_ve))
                {
                    return false;
                }
                if (!this.ve.equals(that.ve))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final createVLAN_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            createVLAN_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VE:
                            if (field.type == TType.STRUCT)
                            {
                                this.ve = new VLanException();
                                this.ve.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetVe())
            {
                oprot.writeFieldBegin(VE_FIELD_DESC);
                this.ve.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("createVLAN_result(");
            boolean first = true;

            sb.append("ve:");
            if (this.ve == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.ve);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class deleteVLAN_args implements TBase<deleteVLAN_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<deleteVLAN_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_args");

        private static final TField VLAN_TAG_FIELD_DESC = new TField("vlanTag",
            TType.I32,
            (short) 1);

        private static final TField VLAN_INTERFACE_FIELD_DESC = new TField("vlanInterface",
            TType.STRING,
            (short) 2);

        private static final TField BRIDGE_INTERFACE_FIELD_DESC = new TField("bridgeInterface",
            TType.STRING,
            (short) 3);

        public int vlanTag;

        public String vlanInterface;

        public String bridgeInterface;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VLAN_TAG((short) 1, "vlanTag"), VLAN_INTERFACE((short) 2, "vlanInterface"), BRIDGE_INTERFACE(
                (short) 3, "bridgeInterface");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments
        private static final int __VLANTAG_ISSET_ID = 0;

        private BitSet __isset_bit_vector = new BitSet(1);

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VLAN_TAG, new FieldMetaData("vlanTag",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.I32)));
                    put(_Fields.VLAN_INTERFACE, new FieldMetaData("vlanInterface",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.BRIDGE_INTERFACE, new FieldMetaData("bridgeInterface",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(deleteVLAN_args.class, metaDataMap);
        }

        public deleteVLAN_args()
        {
        }

        public deleteVLAN_args(final int vlanTag, final String vlanInterface,
            final String bridgeInterface)
        {
            this();
            this.vlanTag = vlanTag;
            setVlanTagIsSet(true);
            this.vlanInterface = vlanInterface;
            this.bridgeInterface = bridgeInterface;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public deleteVLAN_args(final deleteVLAN_args other)
        {
            __isset_bit_vector.clear();
            __isset_bit_vector.or(other.__isset_bit_vector);
            this.vlanTag = other.vlanTag;
            if (other.isSetVlanInterface())
            {
                this.vlanInterface = other.vlanInterface;
            }
            if (other.isSetBridgeInterface())
            {
                this.bridgeInterface = other.bridgeInterface;
            }
        }

        @Override
        public deleteVLAN_args deepCopy()
        {
            return new deleteVLAN_args(this);
        }

        @Override
        @Deprecated
        public deleteVLAN_args clone()
        {
            return new deleteVLAN_args(this);
        }

        public int getVlanTag()
        {
            return this.vlanTag;
        }

        public deleteVLAN_args setVlanTag(final int vlanTag)
        {
            this.vlanTag = vlanTag;
            setVlanTagIsSet(true);
            return this;
        }

        public void unsetVlanTag()
        {
            __isset_bit_vector.clear(__VLANTAG_ISSET_ID);
        }

        /** Returns true if field vlanTag is set (has been asigned a value) and false otherwise */
        public boolean isSetVlanTag()
        {
            return __isset_bit_vector.get(__VLANTAG_ISSET_ID);
        }

        public void setVlanTagIsSet(final boolean value)
        {
            __isset_bit_vector.set(__VLANTAG_ISSET_ID, value);
        }

        public String getVlanInterface()
        {
            return this.vlanInterface;
        }

        public deleteVLAN_args setVlanInterface(final String vlanInterface)
        {
            this.vlanInterface = vlanInterface;
            return this;
        }

        public void unsetVlanInterface()
        {
            this.vlanInterface = null;
        }

        /**
         * Returns true if field vlanInterface is set (has been asigned a value) and false otherwise
         */
        public boolean isSetVlanInterface()
        {
            return this.vlanInterface != null;
        }

        public void setVlanInterfaceIsSet(final boolean value)
        {
            if (!value)
            {
                this.vlanInterface = null;
            }
        }

        public String getBridgeInterface()
        {
            return this.bridgeInterface;
        }

        public deleteVLAN_args setBridgeInterface(final String bridgeInterface)
        {
            this.bridgeInterface = bridgeInterface;
            return this;
        }

        public void unsetBridgeInterface()
        {
            this.bridgeInterface = null;
        }

        /**
         * Returns true if field bridgeInterface is set (has been asigned a value) and false
         * otherwise
         */
        public boolean isSetBridgeInterface()
        {
            return this.bridgeInterface != null;
        }

        public void setBridgeInterfaceIsSet(final boolean value)
        {
            if (!value)
            {
                this.bridgeInterface = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VLAN_TAG:
                    if (value == null)
                    {
                        unsetVlanTag();
                    }
                    else
                    {
                        setVlanTag((Integer) value);
                    }
                    break;

                case VLAN_INTERFACE:
                    if (value == null)
                    {
                        unsetVlanInterface();
                    }
                    else
                    {
                        setVlanInterface((String) value);
                    }
                    break;

                case BRIDGE_INTERFACE:
                    if (value == null)
                    {
                        unsetBridgeInterface();
                    }
                    else
                    {
                        setBridgeInterface((String) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VLAN_TAG:
                    return new Integer(getVlanTag());

                case VLAN_INTERFACE:
                    return getVlanInterface();

                case BRIDGE_INTERFACE:
                    return getBridgeInterface();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VLAN_TAG:
                    return isSetVlanTag();
                case VLAN_INTERFACE:
                    return isSetVlanInterface();
                case BRIDGE_INTERFACE:
                    return isSetBridgeInterface();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof deleteVLAN_args)
            {
                return this.equals((deleteVLAN_args) that);
            }
            return false;
        }

        public boolean equals(final deleteVLAN_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_vlanTag = true;
            boolean that_present_vlanTag = true;
            if (this_present_vlanTag || that_present_vlanTag)
            {
                if (!(this_present_vlanTag && that_present_vlanTag))
                {
                    return false;
                }
                if (this.vlanTag != that.vlanTag)
                {
                    return false;
                }
            }

            boolean this_present_vlanInterface = true && this.isSetVlanInterface();
            boolean that_present_vlanInterface = true && that.isSetVlanInterface();
            if (this_present_vlanInterface || that_present_vlanInterface)
            {
                if (!(this_present_vlanInterface && that_present_vlanInterface))
                {
                    return false;
                }
                if (!this.vlanInterface.equals(that.vlanInterface))
                {
                    return false;
                }
            }

            boolean this_present_bridgeInterface = true && this.isSetBridgeInterface();
            boolean that_present_bridgeInterface = true && that.isSetBridgeInterface();
            if (this_present_bridgeInterface || that_present_bridgeInterface)
            {
                if (!(this_present_bridgeInterface && that_present_bridgeInterface))
                {
                    return false;
                }
                if (!this.bridgeInterface.equals(that.bridgeInterface))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final deleteVLAN_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            deleteVLAN_args typedOther = other;

            lastComparison = Boolean.valueOf(isSetVlanTag()).compareTo(isSetVlanTag());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(vlanTag, typedOther.vlanTag);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetVlanInterface()).compareTo(isSetVlanInterface());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(vlanInterface, typedOther.vlanInterface);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison =
                Boolean.valueOf(isSetBridgeInterface()).compareTo(isSetBridgeInterface());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(bridgeInterface, typedOther.bridgeInterface);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VLAN_TAG:
                            if (field.type == TType.I32)
                            {
                                this.vlanTag = iprot.readI32();
                                setVlanTagIsSet(true);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case VLAN_INTERFACE:
                            if (field.type == TType.STRING)
                            {
                                this.vlanInterface = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case BRIDGE_INTERFACE:
                            if (field.type == TType.STRING)
                            {
                                this.bridgeInterface = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldBegin(VLAN_TAG_FIELD_DESC);
            oprot.writeI32(this.vlanTag);
            oprot.writeFieldEnd();
            if (this.vlanInterface != null)
            {
                oprot.writeFieldBegin(VLAN_INTERFACE_FIELD_DESC);
                oprot.writeString(this.vlanInterface);
                oprot.writeFieldEnd();
            }
            if (this.bridgeInterface != null)
            {
                oprot.writeFieldBegin(BRIDGE_INTERFACE_FIELD_DESC);
                oprot.writeString(this.bridgeInterface);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("deleteVLAN_args(");
            boolean first = true;

            sb.append("vlanTag:");
            sb.append(this.vlanTag);
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("vlanInterface:");
            if (this.vlanInterface == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.vlanInterface);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("bridgeInterface:");
            if (this.bridgeInterface == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.bridgeInterface);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class deleteVLAN_result implements TBase<deleteVLAN_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<deleteVLAN_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("deleteVLAN_result");

        private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short) 1);

        public VLanException ve;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VE((short) 1, "ve");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VE, new FieldMetaData("ve",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(deleteVLAN_result.class, metaDataMap);
        }

        public deleteVLAN_result()
        {
        }

        public deleteVLAN_result(final VLanException ve)
        {
            this();
            this.ve = ve;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public deleteVLAN_result(final deleteVLAN_result other)
        {
            if (other.isSetVe())
            {
                this.ve = new VLanException(other.ve);
            }
        }

        @Override
        public deleteVLAN_result deepCopy()
        {
            return new deleteVLAN_result(this);
        }

        @Override
        @Deprecated
        public deleteVLAN_result clone()
        {
            return new deleteVLAN_result(this);
        }

        public VLanException getVe()
        {
            return this.ve;
        }

        public deleteVLAN_result setVe(final VLanException ve)
        {
            this.ve = ve;
            return this;
        }

        public void unsetVe()
        {
            this.ve = null;
        }

        /** Returns true if field ve is set (has been asigned a value) and false otherwise */
        public boolean isSetVe()
        {
            return this.ve != null;
        }

        public void setVeIsSet(final boolean value)
        {
            if (!value)
            {
                this.ve = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VE:
                    if (value == null)
                    {
                        unsetVe();
                    }
                    else
                    {
                        setVe((VLanException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return getVe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return isSetVe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof deleteVLAN_result)
            {
                return this.equals((deleteVLAN_result) that);
            }
            return false;
        }

        public boolean equals(final deleteVLAN_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_ve = true && this.isSetVe();
            boolean that_present_ve = true && that.isSetVe();
            if (this_present_ve || that_present_ve)
            {
                if (!(this_present_ve && that_present_ve))
                {
                    return false;
                }
                if (!this.ve.equals(that.ve))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final deleteVLAN_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            deleteVLAN_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VE:
                            if (field.type == TType.STRUCT)
                            {
                                this.ve = new VLanException();
                                this.ve.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetVe())
            {
                oprot.writeFieldBegin(VE_FIELD_DESC);
                this.ve.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("deleteVLAN_result(");
            boolean first = true;

            sb.append("ve:");
            if (this.ve == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.ve);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class checkVLANConfiguration_args implements
        TBase<checkVLANConfiguration_args._Fields>, java.io.Serializable, Cloneable,
        Comparable<checkVLANConfiguration_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_args");

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            ;

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_args.class, metaDataMap);
        }

        public checkVLANConfiguration_args()
        {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public checkVLANConfiguration_args(final checkVLANConfiguration_args other)
        {
        }

        @Override
        public checkVLANConfiguration_args deepCopy()
        {
            return new checkVLANConfiguration_args(this);
        }

        @Override
        @Deprecated
        public checkVLANConfiguration_args clone()
        {
            return new checkVLANConfiguration_args(this);
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof checkVLANConfiguration_args)
            {
                return this.equals((checkVLANConfiguration_args) that);
            }
            return false;
        }

        public boolean equals(final checkVLANConfiguration_args that)
        {
            if (that == null)
            {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final checkVLANConfiguration_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            checkVLANConfiguration_args typedOther = other;

            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("checkVLANConfiguration_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class checkVLANConfiguration_result implements
        TBase<checkVLANConfiguration_result._Fields>, java.io.Serializable, Cloneable,
        Comparable<checkVLANConfiguration_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("checkVLANConfiguration_result");

        private static final TField VE_FIELD_DESC = new TField("ve", TType.STRUCT, (short) 1);

        public VLanException ve;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            VE((short) 1, "ve");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.VE, new FieldMetaData("ve",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(checkVLANConfiguration_result.class, metaDataMap);
        }

        public checkVLANConfiguration_result()
        {
        }

        public checkVLANConfiguration_result(final VLanException ve)
        {
            this();
            this.ve = ve;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public checkVLANConfiguration_result(final checkVLANConfiguration_result other)
        {
            if (other.isSetVe())
            {
                this.ve = new VLanException(other.ve);
            }
        }

        @Override
        public checkVLANConfiguration_result deepCopy()
        {
            return new checkVLANConfiguration_result(this);
        }

        @Override
        @Deprecated
        public checkVLANConfiguration_result clone()
        {
            return new checkVLANConfiguration_result(this);
        }

        public VLanException getVe()
        {
            return this.ve;
        }

        public checkVLANConfiguration_result setVe(final VLanException ve)
        {
            this.ve = ve;
            return this;
        }

        public void unsetVe()
        {
            this.ve = null;
        }

        /** Returns true if field ve is set (has been asigned a value) and false otherwise */
        public boolean isSetVe()
        {
            return this.ve != null;
        }

        public void setVeIsSet(final boolean value)
        {
            if (!value)
            {
                this.ve = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case VE:
                    if (value == null)
                    {
                        unsetVe();
                    }
                    else
                    {
                        setVe((VLanException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return getVe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case VE:
                    return isSetVe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof checkVLANConfiguration_result)
            {
                return this.equals((checkVLANConfiguration_result) that);
            }
            return false;
        }

        public boolean equals(final checkVLANConfiguration_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_ve = true && this.isSetVe();
            boolean that_present_ve = true && that.isSetVe();
            if (this_present_ve || that_present_ve)
            {
                if (!(this_present_ve && that_present_ve))
                {
                    return false;
                }
                if (!this.ve.equals(that.ve))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final checkVLANConfiguration_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            checkVLANConfiguration_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetVe()).compareTo(isSetVe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(ve, typedOther.ve);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case VE:
                            if (field.type == TType.STRUCT)
                            {
                                this.ve = new VLanException();
                                this.ve.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetVe())
            {
                oprot.writeFieldBegin(VE_FIELD_DESC);
                this.ve.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("checkVLANConfiguration_result(");
            boolean first = true;

            sb.append("ve:");
            if (this.ve == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.ve);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getInitiatorIQN_args implements TBase<getInitiatorIQN_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<getInitiatorIQN_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_args");

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            ;

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getInitiatorIQN_args.class, metaDataMap);
        }

        public getInitiatorIQN_args()
        {
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getInitiatorIQN_args(final getInitiatorIQN_args other)
        {
        }

        @Override
        public getInitiatorIQN_args deepCopy()
        {
            return new getInitiatorIQN_args(this);
        }

        @Override
        @Deprecated
        public getInitiatorIQN_args clone()
        {
            return new getInitiatorIQN_args(this);
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getInitiatorIQN_args)
            {
                return this.equals((getInitiatorIQN_args) that);
            }
            return false;
        }

        public boolean equals(final getInitiatorIQN_args that)
        {
            if (that == null)
            {
                return false;
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getInitiatorIQN_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getInitiatorIQN_args typedOther = other;

            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getInitiatorIQN_args(");
            boolean first = true;

            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class getInitiatorIQN_result implements TBase<getInitiatorIQN_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<getInitiatorIQN_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("getInitiatorIQN_result");

        private static final TField SUCCESS_FIELD_DESC = new TField("success",
            TType.STRING,
            (short) 0);

        private static final TField SE_FIELD_DESC = new TField("se", TType.STRUCT, (short) 1);

        public String success;

        public StorageException se;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            SUCCESS((short) 0, "success"), SE((short) 1, "se");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.SUCCESS, new FieldMetaData("success",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRING)));
                    put(_Fields.SE, new FieldMetaData("se",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(getInitiatorIQN_result.class, metaDataMap);
        }

        public getInitiatorIQN_result()
        {
        }

        public getInitiatorIQN_result(final String success, final StorageException se)
        {
            this();
            this.success = success;
            this.se = se;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public getInitiatorIQN_result(final getInitiatorIQN_result other)
        {
            if (other.isSetSuccess())
            {
                this.success = other.success;
            }
            if (other.isSetSe())
            {
                this.se = new StorageException(other.se);
            }
        }

        @Override
        public getInitiatorIQN_result deepCopy()
        {
            return new getInitiatorIQN_result(this);
        }

        @Override
        @Deprecated
        public getInitiatorIQN_result clone()
        {
            return new getInitiatorIQN_result(this);
        }

        public String getSuccess()
        {
            return this.success;
        }

        public getInitiatorIQN_result setSuccess(final String success)
        {
            this.success = success;
            return this;
        }

        public void unsetSuccess()
        {
            this.success = null;
        }

        /** Returns true if field success is set (has been asigned a value) and false otherwise */
        public boolean isSetSuccess()
        {
            return this.success != null;
        }

        public void setSuccessIsSet(final boolean value)
        {
            if (!value)
            {
                this.success = null;
            }
        }

        public StorageException getSe()
        {
            return this.se;
        }

        public getInitiatorIQN_result setSe(final StorageException se)
        {
            this.se = se;
            return this;
        }

        public void unsetSe()
        {
            this.se = null;
        }

        /** Returns true if field se is set (has been asigned a value) and false otherwise */
        public boolean isSetSe()
        {
            return this.se != null;
        }

        public void setSeIsSet(final boolean value)
        {
            if (!value)
            {
                this.se = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case SUCCESS:
                    if (value == null)
                    {
                        unsetSuccess();
                    }
                    else
                    {
                        setSuccess((String) value);
                    }
                    break;

                case SE:
                    if (value == null)
                    {
                        unsetSe();
                    }
                    else
                    {
                        setSe((StorageException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return getSuccess();

                case SE:
                    return getSe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case SUCCESS:
                    return isSetSuccess();
                case SE:
                    return isSetSe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof getInitiatorIQN_result)
            {
                return this.equals((getInitiatorIQN_result) that);
            }
            return false;
        }

        public boolean equals(final getInitiatorIQN_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_success = true && this.isSetSuccess();
            boolean that_present_success = true && that.isSetSuccess();
            if (this_present_success || that_present_success)
            {
                if (!(this_present_success && that_present_success))
                {
                    return false;
                }
                if (!this.success.equals(that.success))
                {
                    return false;
                }
            }

            boolean this_present_se = true && this.isSetSe();
            boolean that_present_se = true && that.isSetSe();
            if (this_present_se || that_present_se)
            {
                if (!(this_present_se && that_present_se))
                {
                    return false;
                }
                if (!this.se.equals(that.se))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final getInitiatorIQN_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            getInitiatorIQN_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(isSetSuccess());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(success, typedOther.success);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = Boolean.valueOf(isSetSe()).compareTo(isSetSe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(se, typedOther.se);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case SUCCESS:
                            if (field.type == TType.STRING)
                            {
                                this.success = iprot.readString();
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                        case SE:
                            if (field.type == TType.STRUCT)
                            {
                                this.se = new StorageException();
                                this.se.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSuccess())
            {
                oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
                oprot.writeString(this.success);
                oprot.writeFieldEnd();
            }
            else if (this.isSetSe())
            {
                oprot.writeFieldBegin(SE_FIELD_DESC);
                this.se.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("getInitiatorIQN_result(");
            boolean first = true;

            sb.append("success:");
            if (this.success == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.success);
            }
            first = false;
            if (!first)
            {
                sb.append(", ");
            }
            sb.append("se:");
            if (this.se == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.se);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class rescanISCSI_args implements TBase<rescanISCSI_args._Fields>,
        java.io.Serializable, Cloneable, Comparable<rescanISCSI_args>
    {
        private static final TStruct STRUCT_DESC = new TStruct("rescanISCSI_args");

        private static final TField TARGETS_FIELD_DESC = new TField("targets",
            TType.LIST,
            (short) 1);

        public List<String> targets;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            TARGETS((short) 1, "targets");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.TARGETS, new FieldMetaData("targets",
                        TFieldRequirementType.DEFAULT,
                        new ListMetaData(TType.LIST, new FieldValueMetaData(TType.STRING))));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(rescanISCSI_args.class, metaDataMap);
        }

        public rescanISCSI_args()
        {
        }

        public rescanISCSI_args(final List<String> targets)
        {
            this();
            this.targets = targets;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public rescanISCSI_args(final rescanISCSI_args other)
        {
            if (other.isSetTargets())
            {
                List<String> __this__targets = new ArrayList<String>();
                for (String other_element : other.targets)
                {
                    __this__targets.add(other_element);
                }
                this.targets = __this__targets;
            }
        }

        @Override
        public rescanISCSI_args deepCopy()
        {
            return new rescanISCSI_args(this);
        }

        @Override
        @Deprecated
        public rescanISCSI_args clone()
        {
            return new rescanISCSI_args(this);
        }

        public int getTargetsSize()
        {
            return this.targets == null ? 0 : this.targets.size();
        }

        public java.util.Iterator<String> getTargetsIterator()
        {
            return this.targets == null ? null : this.targets.iterator();
        }

        public void addToTargets(final String elem)
        {
            if (this.targets == null)
            {
                this.targets = new ArrayList<String>();
            }
            this.targets.add(elem);
        }

        public List<String> getTargets()
        {
            return this.targets;
        }

        public rescanISCSI_args setTargets(final List<String> targets)
        {
            this.targets = targets;
            return this;
        }

        public void unsetTargets()
        {
            this.targets = null;
        }

        /** Returns true if field targets is set (has been asigned a value) and false otherwise */
        public boolean isSetTargets()
        {
            return this.targets != null;
        }

        public void setTargetsIsSet(final boolean value)
        {
            if (!value)
            {
                this.targets = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case TARGETS:
                    if (value == null)
                    {
                        unsetTargets();
                    }
                    else
                    {
                        setTargets((List<String>) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case TARGETS:
                    return getTargets();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case TARGETS:
                    return isSetTargets();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof rescanISCSI_args)
            {
                return this.equals((rescanISCSI_args) that);
            }
            return false;
        }

        public boolean equals(final rescanISCSI_args that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_targets = true && this.isSetTargets();
            boolean that_present_targets = true && that.isSetTargets();
            if (this_present_targets || that_present_targets)
            {
                if (!(this_present_targets && that_present_targets))
                {
                    return false;
                }
                if (!this.targets.equals(that.targets))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final rescanISCSI_args other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            rescanISCSI_args typedOther = other;

            lastComparison = Boolean.valueOf(isSetTargets()).compareTo(isSetTargets());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(targets, typedOther.targets);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case TARGETS:
                            if (field.type == TType.LIST)
                            {
                                {
                                    TList _list8 = iprot.readListBegin();
                                    this.targets = new ArrayList<String>(_list8.size);
                                    for (int _i9 = 0; _i9 < _list8.size; ++_i9)
                                    {
                                        String _elem10;
                                        _elem10 = iprot.readString();
                                        this.targets.add(_elem10);
                                    }
                                    iprot.readListEnd();
                                }
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            validate();

            oprot.writeStructBegin(STRUCT_DESC);
            if (this.targets != null)
            {
                oprot.writeFieldBegin(TARGETS_FIELD_DESC);
                {
                    oprot.writeListBegin(new TList(TType.STRING, this.targets.size()));
                    for (String _iter11 : this.targets)
                    {
                        oprot.writeString(_iter11);
                    }
                    oprot.writeListEnd();
                }
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("rescanISCSI_args(");
            boolean first = true;

            sb.append("targets:");
            if (this.targets == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.targets);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

    public static class rescanISCSI_result implements TBase<rescanISCSI_result._Fields>,
        java.io.Serializable, Cloneable, Comparable<rescanISCSI_result>
    {
        private static final TStruct STRUCT_DESC = new TStruct("rescanISCSI_result");

        private static final TField SE_FIELD_DESC = new TField("se", TType.STRUCT, (short) 1);

        public StorageException se;

        /**
         * The set of fields this struct contains, along with convenience methods for finding and
         * manipulating them.
         */
        public enum _Fields implements TFieldIdEnum
        {
            SE((short) 1, "se");

            private static final Map<Integer, _Fields> byId = new HashMap<Integer, _Fields>();

            private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

            static
            {
                for (_Fields field : EnumSet.allOf(_Fields.class))
                {
                    byId.put((int) field._thriftId, field);
                    byName.put(field.getFieldName(), field);
                }
            }

            /**
             * Find the _Fields constant that matches fieldId, or null if its not found.
             */
            public static _Fields findByThriftId(final int fieldId)
            {
                return byId.get(fieldId);
            }

            /**
             * Find the _Fields constant that matches fieldId, throwing an exception if it is not
             * found.
             */
            public static _Fields findByThriftIdOrThrow(final int fieldId)
            {
                _Fields fields = findByThriftId(fieldId);
                if (fields == null)
                {
                    throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
                }
                return fields;
            }

            /**
             * Find the _Fields constant that matches name, or null if its not found.
             */
            public static _Fields findByName(final String name)
            {
                return byName.get(name);
            }

            private final short _thriftId;

            private final String _fieldName;

            _Fields(final short thriftId, final String fieldName)
            {
                _thriftId = thriftId;
                _fieldName = fieldName;
            }

            @Override
            public short getThriftFieldId()
            {
                return _thriftId;
            }

            @Override
            public String getFieldName()
            {
                return _fieldName;
            }
        }

        // isset id assignments

        public static final Map<_Fields, FieldMetaData> metaDataMap = Collections
            .unmodifiableMap(new EnumMap<_Fields, FieldMetaData>(_Fields.class)
            {
                {
                    put(_Fields.SE, new FieldMetaData("se",
                        TFieldRequirementType.DEFAULT,
                        new FieldValueMetaData(TType.STRUCT)));
                }
            });

        static
        {
            FieldMetaData.addStructMetaDataMap(rescanISCSI_result.class, metaDataMap);
        }

        public rescanISCSI_result()
        {
        }

        public rescanISCSI_result(final StorageException se)
        {
            this();
            this.se = se;
        }

        /**
         * Performs a deep copy on <i>other</i>.
         */
        public rescanISCSI_result(final rescanISCSI_result other)
        {
            if (other.isSetSe())
            {
                this.se = new StorageException(other.se);
            }
        }

        @Override
        public rescanISCSI_result deepCopy()
        {
            return new rescanISCSI_result(this);
        }

        @Override
        @Deprecated
        public rescanISCSI_result clone()
        {
            return new rescanISCSI_result(this);
        }

        public StorageException getSe()
        {
            return this.se;
        }

        public rescanISCSI_result setSe(final StorageException se)
        {
            this.se = se;
            return this;
        }

        public void unsetSe()
        {
            this.se = null;
        }

        /** Returns true if field se is set (has been asigned a value) and false otherwise */
        public boolean isSetSe()
        {
            return this.se != null;
        }

        public void setSeIsSet(final boolean value)
        {
            if (!value)
            {
                this.se = null;
            }
        }

        @Override
        public void setFieldValue(final _Fields field, final Object value)
        {
            switch (field)
            {
                case SE:
                    if (value == null)
                    {
                        unsetSe();
                    }
                    else
                    {
                        setSe((StorageException) value);
                    }
                    break;

            }
        }

        @Override
        public void setFieldValue(final int fieldID, final Object value)
        {
            setFieldValue(_Fields.findByThriftIdOrThrow(fieldID), value);
        }

        @Override
        public Object getFieldValue(final _Fields field)
        {
            switch (field)
            {
                case SE:
                    return getSe();

            }
            throw new IllegalStateException();
        }

        @Override
        public Object getFieldValue(final int fieldId)
        {
            return getFieldValue(_Fields.findByThriftIdOrThrow(fieldId));
        }

        /**
         * Returns true if field corresponding to fieldID is set (has been asigned a value) and
         * false otherwise
         */
        @Override
        public boolean isSet(final _Fields field)
        {
            switch (field)
            {
                case SE:
                    return isSetSe();
            }
            throw new IllegalStateException();
        }

        @Override
        public boolean isSet(final int fieldID)
        {
            return isSet(_Fields.findByThriftIdOrThrow(fieldID));
        }

        @Override
        public boolean equals(final Object that)
        {
            if (that == null)
            {
                return false;
            }
            if (that instanceof rescanISCSI_result)
            {
                return this.equals((rescanISCSI_result) that);
            }
            return false;
        }

        public boolean equals(final rescanISCSI_result that)
        {
            if (that == null)
            {
                return false;
            }

            boolean this_present_se = true && this.isSetSe();
            boolean that_present_se = true && that.isSetSe();
            if (this_present_se || that_present_se)
            {
                if (!(this_present_se && that_present_se))
                {
                    return false;
                }
                if (!this.se.equals(that.se))
                {
                    return false;
                }
            }

            return true;
        }

        @Override
        public int hashCode()
        {
            return 0;
        }

        @Override
        public int compareTo(final rescanISCSI_result other)
        {
            if (!getClass().equals(other.getClass()))
            {
                return getClass().getName().compareTo(other.getClass().getName());
            }

            int lastComparison = 0;
            rescanISCSI_result typedOther = other;

            lastComparison = Boolean.valueOf(isSetSe()).compareTo(isSetSe());
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            lastComparison = TBaseHelper.compareTo(se, typedOther.se);
            if (lastComparison != 0)
            {
                return lastComparison;
            }
            return 0;
        }

        @Override
        public void read(final TProtocol iprot) throws TException
        {
            TField field;
            iprot.readStructBegin();
            while (true)
            {
                field = iprot.readFieldBegin();
                if (field.type == TType.STOP)
                {
                    break;
                }
                _Fields fieldId = _Fields.findByThriftId(field.id);
                if (fieldId == null)
                {
                    TProtocolUtil.skip(iprot, field.type);
                }
                else
                {
                    switch (fieldId)
                    {
                        case SE:
                            if (field.type == TType.STRUCT)
                            {
                                this.se = new StorageException();
                                this.se.read(iprot);
                            }
                            else
                            {
                                TProtocolUtil.skip(iprot, field.type);
                            }
                            break;
                    }
                    iprot.readFieldEnd();
                }
            }
            iprot.readStructEnd();

            // check for required fields of primitive type, which can't be checked in the validate
            // method
            validate();
        }

        @Override
        public void write(final TProtocol oprot) throws TException
        {
            oprot.writeStructBegin(STRUCT_DESC);

            if (this.isSetSe())
            {
                oprot.writeFieldBegin(SE_FIELD_DESC);
                this.se.write(oprot);
                oprot.writeFieldEnd();
            }
            oprot.writeFieldStop();
            oprot.writeStructEnd();
        }

        @Override
        public String toString()
        {
            StringBuilder sb = new StringBuilder("rescanISCSI_result(");
            boolean first = true;

            sb.append("se:");
            if (this.se == null)
            {
                sb.append("null");
            }
            else
            {
                sb.append(this.se);
            }
            first = false;
            sb.append(")");
            return sb.toString();
        }

        public void validate() throws TException
        {
            // check for required fields
        }

    }

}
